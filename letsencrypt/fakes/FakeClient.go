// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"crypto"
	"crypto/tls"
	"sync"
	"time"

	"github.com/18F/cf-cdn-service-broker/letsencrypt"
	"golang.org/x/crypto/acme"
)

type FakeClientInterface struct {
	AcceptStub        func(context.Context, *acme.Challenge) (*acme.Challenge, error)
	acceptMutex       sync.RWMutex
	acceptArgsForCall []struct {
		arg1 context.Context
		arg2 *acme.Challenge
	}
	acceptReturns struct {
		result1 *acme.Challenge
		result2 error
	}
	acceptReturnsOnCall map[int]struct {
		result1 *acme.Challenge
		result2 error
	}
	AuthorizeStub        func(context.Context, string) (*acme.Authorization, error)
	authorizeMutex       sync.RWMutex
	authorizeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	authorizeReturns struct {
		result1 *acme.Authorization
		result2 error
	}
	authorizeReturnsOnCall map[int]struct {
		result1 *acme.Authorization
		result2 error
	}
	AuthorizeIPStub        func(context.Context, string) (*acme.Authorization, error)
	authorizeIPMutex       sync.RWMutex
	authorizeIPArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	authorizeIPReturns struct {
		result1 *acme.Authorization
		result2 error
	}
	authorizeIPReturnsOnCall map[int]struct {
		result1 *acme.Authorization
		result2 error
	}
	AuthorizeOrderStub        func(context.Context, []acme.AuthzID, ...acme.OrderOption) (*acme.Order, error)
	authorizeOrderMutex       sync.RWMutex
	authorizeOrderArgsForCall []struct {
		arg1 context.Context
		arg2 []acme.AuthzID
		arg3 []acme.OrderOption
	}
	authorizeOrderReturns struct {
		result1 *acme.Order
		result2 error
	}
	authorizeOrderReturnsOnCall map[int]struct {
		result1 *acme.Order
		result2 error
	}
	CreateCertStub        func(context.Context, []byte, time.Duration, bool) ([][]byte, string, error)
	createCertMutex       sync.RWMutex
	createCertArgsForCall []struct {
		arg1 context.Context
		arg2 []byte
		arg3 time.Duration
		arg4 bool
	}
	createCertReturns struct {
		result1 [][]byte
		result2 string
		result3 error
	}
	createCertReturnsOnCall map[int]struct {
		result1 [][]byte
		result2 string
		result3 error
	}
	CreateOrderCertStub        func(context.Context, string, []byte, bool) ([][]byte, string, error)
	createOrderCertMutex       sync.RWMutex
	createOrderCertArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
		arg4 bool
	}
	createOrderCertReturns struct {
		result1 [][]byte
		result2 string
		result3 error
	}
	createOrderCertReturnsOnCall map[int]struct {
		result1 [][]byte
		result2 string
		result3 error
	}
	DNS01ChallengeRecordStub        func(string) (string, error)
	dNS01ChallengeRecordMutex       sync.RWMutex
	dNS01ChallengeRecordArgsForCall []struct {
		arg1 string
	}
	dNS01ChallengeRecordReturns struct {
		result1 string
		result2 error
	}
	dNS01ChallengeRecordReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DeactivateRegStub        func(context.Context) error
	deactivateRegMutex       sync.RWMutex
	deactivateRegArgsForCall []struct {
		arg1 context.Context
	}
	deactivateRegReturns struct {
		result1 error
	}
	deactivateRegReturnsOnCall map[int]struct {
		result1 error
	}
	DiscoverStub        func(context.Context) (acme.Directory, error)
	discoverMutex       sync.RWMutex
	discoverArgsForCall []struct {
		arg1 context.Context
	}
	discoverReturns struct {
		result1 acme.Directory
		result2 error
	}
	discoverReturnsOnCall map[int]struct {
		result1 acme.Directory
		result2 error
	}
	FetchCertStub        func(context.Context, string, bool) ([][]byte, error)
	fetchCertMutex       sync.RWMutex
	fetchCertArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}
	fetchCertReturns struct {
		result1 [][]byte
		result2 error
	}
	fetchCertReturnsOnCall map[int]struct {
		result1 [][]byte
		result2 error
	}
	GetAuthorizationStub        func(context.Context, string) (*acme.Authorization, error)
	getAuthorizationMutex       sync.RWMutex
	getAuthorizationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getAuthorizationReturns struct {
		result1 *acme.Authorization
		result2 error
	}
	getAuthorizationReturnsOnCall map[int]struct {
		result1 *acme.Authorization
		result2 error
	}
	GetChallengeStub        func(context.Context, string) (*acme.Challenge, error)
	getChallengeMutex       sync.RWMutex
	getChallengeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getChallengeReturns struct {
		result1 *acme.Challenge
		result2 error
	}
	getChallengeReturnsOnCall map[int]struct {
		result1 *acme.Challenge
		result2 error
	}
	GetKeyStub        func() crypto.Signer
	getKeyMutex       sync.RWMutex
	getKeyArgsForCall []struct {
	}
	getKeyReturns struct {
		result1 crypto.Signer
	}
	getKeyReturnsOnCall map[int]struct {
		result1 crypto.Signer
	}
	GetOrderStub        func(context.Context, string) (*acme.Order, error)
	getOrderMutex       sync.RWMutex
	getOrderArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getOrderReturns struct {
		result1 *acme.Order
		result2 error
	}
	getOrderReturnsOnCall map[int]struct {
		result1 *acme.Order
		result2 error
	}
	GetRegStub        func(context.Context, string) (*acme.Account, error)
	getRegMutex       sync.RWMutex
	getRegArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getRegReturns struct {
		result1 *acme.Account
		result2 error
	}
	getRegReturnsOnCall map[int]struct {
		result1 *acme.Account
		result2 error
	}
	HTTP01ChallengePathStub        func(string) string
	hTTP01ChallengePathMutex       sync.RWMutex
	hTTP01ChallengePathArgsForCall []struct {
		arg1 string
	}
	hTTP01ChallengePathReturns struct {
		result1 string
	}
	hTTP01ChallengePathReturnsOnCall map[int]struct {
		result1 string
	}
	HTTP01ChallengeResponseStub        func(string) (string, error)
	hTTP01ChallengeResponseMutex       sync.RWMutex
	hTTP01ChallengeResponseArgsForCall []struct {
		arg1 string
	}
	hTTP01ChallengeResponseReturns struct {
		result1 string
		result2 error
	}
	hTTP01ChallengeResponseReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RegisterStub        func(context.Context, *acme.Account, func(tosURL string) bool) (*acme.Account, error)
	registerMutex       sync.RWMutex
	registerArgsForCall []struct {
		arg1 context.Context
		arg2 *acme.Account
		arg3 func(tosURL string) bool
	}
	registerReturns struct {
		result1 *acme.Account
		result2 error
	}
	registerReturnsOnCall map[int]struct {
		result1 *acme.Account
		result2 error
	}
	RevokeAuthorizationStub        func(context.Context, string) error
	revokeAuthorizationMutex       sync.RWMutex
	revokeAuthorizationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	revokeAuthorizationReturns struct {
		result1 error
	}
	revokeAuthorizationReturnsOnCall map[int]struct {
		result1 error
	}
	RevokeCertStub        func(context.Context, crypto.Signer, []byte, acme.CRLReasonCode) error
	revokeCertMutex       sync.RWMutex
	revokeCertArgsForCall []struct {
		arg1 context.Context
		arg2 crypto.Signer
		arg3 []byte
		arg4 acme.CRLReasonCode
	}
	revokeCertReturns struct {
		result1 error
	}
	revokeCertReturnsOnCall map[int]struct {
		result1 error
	}
	TLSALPN01ChallengeCertStub        func(string, string, ...acme.CertOption) (tls.Certificate, error)
	tLSALPN01ChallengeCertMutex       sync.RWMutex
	tLSALPN01ChallengeCertArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []acme.CertOption
	}
	tLSALPN01ChallengeCertReturns struct {
		result1 tls.Certificate
		result2 error
	}
	tLSALPN01ChallengeCertReturnsOnCall map[int]struct {
		result1 tls.Certificate
		result2 error
	}
	TLSSNI01ChallengeCertStub        func(string, ...acme.CertOption) (tls.Certificate, string, error)
	tLSSNI01ChallengeCertMutex       sync.RWMutex
	tLSSNI01ChallengeCertArgsForCall []struct {
		arg1 string
		arg2 []acme.CertOption
	}
	tLSSNI01ChallengeCertReturns struct {
		result1 tls.Certificate
		result2 string
		result3 error
	}
	tLSSNI01ChallengeCertReturnsOnCall map[int]struct {
		result1 tls.Certificate
		result2 string
		result3 error
	}
	TLSSNI02ChallengeCertStub        func(string, ...acme.CertOption) (tls.Certificate, string, error)
	tLSSNI02ChallengeCertMutex       sync.RWMutex
	tLSSNI02ChallengeCertArgsForCall []struct {
		arg1 string
		arg2 []acme.CertOption
	}
	tLSSNI02ChallengeCertReturns struct {
		result1 tls.Certificate
		result2 string
		result3 error
	}
	tLSSNI02ChallengeCertReturnsOnCall map[int]struct {
		result1 tls.Certificate
		result2 string
		result3 error
	}
	UpdateRegStub        func(context.Context, *acme.Account) (*acme.Account, error)
	updateRegMutex       sync.RWMutex
	updateRegArgsForCall []struct {
		arg1 context.Context
		arg2 *acme.Account
	}
	updateRegReturns struct {
		result1 *acme.Account
		result2 error
	}
	updateRegReturnsOnCall map[int]struct {
		result1 *acme.Account
		result2 error
	}
	WaitAuthorizationStub        func(context.Context, string) (*acme.Authorization, error)
	waitAuthorizationMutex       sync.RWMutex
	waitAuthorizationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	waitAuthorizationReturns struct {
		result1 *acme.Authorization
		result2 error
	}
	waitAuthorizationReturnsOnCall map[int]struct {
		result1 *acme.Authorization
		result2 error
	}
	WaitOrderStub        func(context.Context, string) (*acme.Order, error)
	waitOrderMutex       sync.RWMutex
	waitOrderArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	waitOrderReturns struct {
		result1 *acme.Order
		result2 error
	}
	waitOrderReturnsOnCall map[int]struct {
		result1 *acme.Order
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClientInterface) Accept(arg1 context.Context, arg2 *acme.Challenge) (*acme.Challenge, error) {
	fake.acceptMutex.Lock()
	ret, specificReturn := fake.acceptReturnsOnCall[len(fake.acceptArgsForCall)]
	fake.acceptArgsForCall = append(fake.acceptArgsForCall, struct {
		arg1 context.Context
		arg2 *acme.Challenge
	}{arg1, arg2})
	fake.recordInvocation("Accept", []interface{}{arg1, arg2})
	fake.acceptMutex.Unlock()
	if fake.AcceptStub != nil {
		return fake.AcceptStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.acceptReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) AcceptCallCount() int {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	return len(fake.acceptArgsForCall)
}

func (fake *FakeClientInterface) AcceptCalls(stub func(context.Context, *acme.Challenge) (*acme.Challenge, error)) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = stub
}

func (fake *FakeClientInterface) AcceptArgsForCall(i int) (context.Context, *acme.Challenge) {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	argsForCall := fake.acceptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) AcceptReturns(result1 *acme.Challenge, result2 error) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = nil
	fake.acceptReturns = struct {
		result1 *acme.Challenge
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) AcceptReturnsOnCall(i int, result1 *acme.Challenge, result2 error) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = nil
	if fake.acceptReturnsOnCall == nil {
		fake.acceptReturnsOnCall = make(map[int]struct {
			result1 *acme.Challenge
			result2 error
		})
	}
	fake.acceptReturnsOnCall[i] = struct {
		result1 *acme.Challenge
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) Authorize(arg1 context.Context, arg2 string) (*acme.Authorization, error) {
	fake.authorizeMutex.Lock()
	ret, specificReturn := fake.authorizeReturnsOnCall[len(fake.authorizeArgsForCall)]
	fake.authorizeArgsForCall = append(fake.authorizeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Authorize", []interface{}{arg1, arg2})
	fake.authorizeMutex.Unlock()
	if fake.AuthorizeStub != nil {
		return fake.AuthorizeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.authorizeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) AuthorizeCallCount() int {
	fake.authorizeMutex.RLock()
	defer fake.authorizeMutex.RUnlock()
	return len(fake.authorizeArgsForCall)
}

func (fake *FakeClientInterface) AuthorizeCalls(stub func(context.Context, string) (*acme.Authorization, error)) {
	fake.authorizeMutex.Lock()
	defer fake.authorizeMutex.Unlock()
	fake.AuthorizeStub = stub
}

func (fake *FakeClientInterface) AuthorizeArgsForCall(i int) (context.Context, string) {
	fake.authorizeMutex.RLock()
	defer fake.authorizeMutex.RUnlock()
	argsForCall := fake.authorizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) AuthorizeReturns(result1 *acme.Authorization, result2 error) {
	fake.authorizeMutex.Lock()
	defer fake.authorizeMutex.Unlock()
	fake.AuthorizeStub = nil
	fake.authorizeReturns = struct {
		result1 *acme.Authorization
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) AuthorizeReturnsOnCall(i int, result1 *acme.Authorization, result2 error) {
	fake.authorizeMutex.Lock()
	defer fake.authorizeMutex.Unlock()
	fake.AuthorizeStub = nil
	if fake.authorizeReturnsOnCall == nil {
		fake.authorizeReturnsOnCall = make(map[int]struct {
			result1 *acme.Authorization
			result2 error
		})
	}
	fake.authorizeReturnsOnCall[i] = struct {
		result1 *acme.Authorization
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) AuthorizeIP(arg1 context.Context, arg2 string) (*acme.Authorization, error) {
	fake.authorizeIPMutex.Lock()
	ret, specificReturn := fake.authorizeIPReturnsOnCall[len(fake.authorizeIPArgsForCall)]
	fake.authorizeIPArgsForCall = append(fake.authorizeIPArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("AuthorizeIP", []interface{}{arg1, arg2})
	fake.authorizeIPMutex.Unlock()
	if fake.AuthorizeIPStub != nil {
		return fake.AuthorizeIPStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.authorizeIPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) AuthorizeIPCallCount() int {
	fake.authorizeIPMutex.RLock()
	defer fake.authorizeIPMutex.RUnlock()
	return len(fake.authorizeIPArgsForCall)
}

func (fake *FakeClientInterface) AuthorizeIPCalls(stub func(context.Context, string) (*acme.Authorization, error)) {
	fake.authorizeIPMutex.Lock()
	defer fake.authorizeIPMutex.Unlock()
	fake.AuthorizeIPStub = stub
}

func (fake *FakeClientInterface) AuthorizeIPArgsForCall(i int) (context.Context, string) {
	fake.authorizeIPMutex.RLock()
	defer fake.authorizeIPMutex.RUnlock()
	argsForCall := fake.authorizeIPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) AuthorizeIPReturns(result1 *acme.Authorization, result2 error) {
	fake.authorizeIPMutex.Lock()
	defer fake.authorizeIPMutex.Unlock()
	fake.AuthorizeIPStub = nil
	fake.authorizeIPReturns = struct {
		result1 *acme.Authorization
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) AuthorizeIPReturnsOnCall(i int, result1 *acme.Authorization, result2 error) {
	fake.authorizeIPMutex.Lock()
	defer fake.authorizeIPMutex.Unlock()
	fake.AuthorizeIPStub = nil
	if fake.authorizeIPReturnsOnCall == nil {
		fake.authorizeIPReturnsOnCall = make(map[int]struct {
			result1 *acme.Authorization
			result2 error
		})
	}
	fake.authorizeIPReturnsOnCall[i] = struct {
		result1 *acme.Authorization
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) AuthorizeOrder(arg1 context.Context, arg2 []acme.AuthzID, arg3 ...acme.OrderOption) (*acme.Order, error) {
	var arg2Copy []acme.AuthzID
	if arg2 != nil {
		arg2Copy = make([]acme.AuthzID, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.authorizeOrderMutex.Lock()
	ret, specificReturn := fake.authorizeOrderReturnsOnCall[len(fake.authorizeOrderArgsForCall)]
	fake.authorizeOrderArgsForCall = append(fake.authorizeOrderArgsForCall, struct {
		arg1 context.Context
		arg2 []acme.AuthzID
		arg3 []acme.OrderOption
	}{arg1, arg2Copy, arg3})
	fake.recordInvocation("AuthorizeOrder", []interface{}{arg1, arg2Copy, arg3})
	fake.authorizeOrderMutex.Unlock()
	if fake.AuthorizeOrderStub != nil {
		return fake.AuthorizeOrderStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.authorizeOrderReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) AuthorizeOrderCallCount() int {
	fake.authorizeOrderMutex.RLock()
	defer fake.authorizeOrderMutex.RUnlock()
	return len(fake.authorizeOrderArgsForCall)
}

func (fake *FakeClientInterface) AuthorizeOrderCalls(stub func(context.Context, []acme.AuthzID, ...acme.OrderOption) (*acme.Order, error)) {
	fake.authorizeOrderMutex.Lock()
	defer fake.authorizeOrderMutex.Unlock()
	fake.AuthorizeOrderStub = stub
}

func (fake *FakeClientInterface) AuthorizeOrderArgsForCall(i int) (context.Context, []acme.AuthzID, []acme.OrderOption) {
	fake.authorizeOrderMutex.RLock()
	defer fake.authorizeOrderMutex.RUnlock()
	argsForCall := fake.authorizeOrderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClientInterface) AuthorizeOrderReturns(result1 *acme.Order, result2 error) {
	fake.authorizeOrderMutex.Lock()
	defer fake.authorizeOrderMutex.Unlock()
	fake.AuthorizeOrderStub = nil
	fake.authorizeOrderReturns = struct {
		result1 *acme.Order
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) AuthorizeOrderReturnsOnCall(i int, result1 *acme.Order, result2 error) {
	fake.authorizeOrderMutex.Lock()
	defer fake.authorizeOrderMutex.Unlock()
	fake.AuthorizeOrderStub = nil
	if fake.authorizeOrderReturnsOnCall == nil {
		fake.authorizeOrderReturnsOnCall = make(map[int]struct {
			result1 *acme.Order
			result2 error
		})
	}
	fake.authorizeOrderReturnsOnCall[i] = struct {
		result1 *acme.Order
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) CreateCert(arg1 context.Context, arg2 []byte, arg3 time.Duration, arg4 bool) ([][]byte, string, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.createCertMutex.Lock()
	ret, specificReturn := fake.createCertReturnsOnCall[len(fake.createCertArgsForCall)]
	fake.createCertArgsForCall = append(fake.createCertArgsForCall, struct {
		arg1 context.Context
		arg2 []byte
		arg3 time.Duration
		arg4 bool
	}{arg1, arg2Copy, arg3, arg4})
	fake.recordInvocation("CreateCert", []interface{}{arg1, arg2Copy, arg3, arg4})
	fake.createCertMutex.Unlock()
	if fake.CreateCertStub != nil {
		return fake.CreateCertStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.createCertReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientInterface) CreateCertCallCount() int {
	fake.createCertMutex.RLock()
	defer fake.createCertMutex.RUnlock()
	return len(fake.createCertArgsForCall)
}

func (fake *FakeClientInterface) CreateCertCalls(stub func(context.Context, []byte, time.Duration, bool) ([][]byte, string, error)) {
	fake.createCertMutex.Lock()
	defer fake.createCertMutex.Unlock()
	fake.CreateCertStub = stub
}

func (fake *FakeClientInterface) CreateCertArgsForCall(i int) (context.Context, []byte, time.Duration, bool) {
	fake.createCertMutex.RLock()
	defer fake.createCertMutex.RUnlock()
	argsForCall := fake.createCertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClientInterface) CreateCertReturns(result1 [][]byte, result2 string, result3 error) {
	fake.createCertMutex.Lock()
	defer fake.createCertMutex.Unlock()
	fake.CreateCertStub = nil
	fake.createCertReturns = struct {
		result1 [][]byte
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientInterface) CreateCertReturnsOnCall(i int, result1 [][]byte, result2 string, result3 error) {
	fake.createCertMutex.Lock()
	defer fake.createCertMutex.Unlock()
	fake.CreateCertStub = nil
	if fake.createCertReturnsOnCall == nil {
		fake.createCertReturnsOnCall = make(map[int]struct {
			result1 [][]byte
			result2 string
			result3 error
		})
	}
	fake.createCertReturnsOnCall[i] = struct {
		result1 [][]byte
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientInterface) CreateOrderCert(arg1 context.Context, arg2 string, arg3 []byte, arg4 bool) ([][]byte, string, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.createOrderCertMutex.Lock()
	ret, specificReturn := fake.createOrderCertReturnsOnCall[len(fake.createOrderCertArgsForCall)]
	fake.createOrderCertArgsForCall = append(fake.createOrderCertArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
		arg4 bool
	}{arg1, arg2, arg3Copy, arg4})
	fake.recordInvocation("CreateOrderCert", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.createOrderCertMutex.Unlock()
	if fake.CreateOrderCertStub != nil {
		return fake.CreateOrderCertStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.createOrderCertReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientInterface) CreateOrderCertCallCount() int {
	fake.createOrderCertMutex.RLock()
	defer fake.createOrderCertMutex.RUnlock()
	return len(fake.createOrderCertArgsForCall)
}

func (fake *FakeClientInterface) CreateOrderCertCalls(stub func(context.Context, string, []byte, bool) ([][]byte, string, error)) {
	fake.createOrderCertMutex.Lock()
	defer fake.createOrderCertMutex.Unlock()
	fake.CreateOrderCertStub = stub
}

func (fake *FakeClientInterface) CreateOrderCertArgsForCall(i int) (context.Context, string, []byte, bool) {
	fake.createOrderCertMutex.RLock()
	defer fake.createOrderCertMutex.RUnlock()
	argsForCall := fake.createOrderCertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClientInterface) CreateOrderCertReturns(result1 [][]byte, result2 string, result3 error) {
	fake.createOrderCertMutex.Lock()
	defer fake.createOrderCertMutex.Unlock()
	fake.CreateOrderCertStub = nil
	fake.createOrderCertReturns = struct {
		result1 [][]byte
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientInterface) CreateOrderCertReturnsOnCall(i int, result1 [][]byte, result2 string, result3 error) {
	fake.createOrderCertMutex.Lock()
	defer fake.createOrderCertMutex.Unlock()
	fake.CreateOrderCertStub = nil
	if fake.createOrderCertReturnsOnCall == nil {
		fake.createOrderCertReturnsOnCall = make(map[int]struct {
			result1 [][]byte
			result2 string
			result3 error
		})
	}
	fake.createOrderCertReturnsOnCall[i] = struct {
		result1 [][]byte
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientInterface) DNS01ChallengeRecord(arg1 string) (string, error) {
	fake.dNS01ChallengeRecordMutex.Lock()
	ret, specificReturn := fake.dNS01ChallengeRecordReturnsOnCall[len(fake.dNS01ChallengeRecordArgsForCall)]
	fake.dNS01ChallengeRecordArgsForCall = append(fake.dNS01ChallengeRecordArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DNS01ChallengeRecord", []interface{}{arg1})
	fake.dNS01ChallengeRecordMutex.Unlock()
	if fake.DNS01ChallengeRecordStub != nil {
		return fake.DNS01ChallengeRecordStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.dNS01ChallengeRecordReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) DNS01ChallengeRecordCallCount() int {
	fake.dNS01ChallengeRecordMutex.RLock()
	defer fake.dNS01ChallengeRecordMutex.RUnlock()
	return len(fake.dNS01ChallengeRecordArgsForCall)
}

func (fake *FakeClientInterface) DNS01ChallengeRecordCalls(stub func(string) (string, error)) {
	fake.dNS01ChallengeRecordMutex.Lock()
	defer fake.dNS01ChallengeRecordMutex.Unlock()
	fake.DNS01ChallengeRecordStub = stub
}

func (fake *FakeClientInterface) DNS01ChallengeRecordArgsForCall(i int) string {
	fake.dNS01ChallengeRecordMutex.RLock()
	defer fake.dNS01ChallengeRecordMutex.RUnlock()
	argsForCall := fake.dNS01ChallengeRecordArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) DNS01ChallengeRecordReturns(result1 string, result2 error) {
	fake.dNS01ChallengeRecordMutex.Lock()
	defer fake.dNS01ChallengeRecordMutex.Unlock()
	fake.DNS01ChallengeRecordStub = nil
	fake.dNS01ChallengeRecordReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) DNS01ChallengeRecordReturnsOnCall(i int, result1 string, result2 error) {
	fake.dNS01ChallengeRecordMutex.Lock()
	defer fake.dNS01ChallengeRecordMutex.Unlock()
	fake.DNS01ChallengeRecordStub = nil
	if fake.dNS01ChallengeRecordReturnsOnCall == nil {
		fake.dNS01ChallengeRecordReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.dNS01ChallengeRecordReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) DeactivateReg(arg1 context.Context) error {
	fake.deactivateRegMutex.Lock()
	ret, specificReturn := fake.deactivateRegReturnsOnCall[len(fake.deactivateRegArgsForCall)]
	fake.deactivateRegArgsForCall = append(fake.deactivateRegArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("DeactivateReg", []interface{}{arg1})
	fake.deactivateRegMutex.Unlock()
	if fake.DeactivateRegStub != nil {
		return fake.DeactivateRegStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deactivateRegReturns
	return fakeReturns.result1
}

func (fake *FakeClientInterface) DeactivateRegCallCount() int {
	fake.deactivateRegMutex.RLock()
	defer fake.deactivateRegMutex.RUnlock()
	return len(fake.deactivateRegArgsForCall)
}

func (fake *FakeClientInterface) DeactivateRegCalls(stub func(context.Context) error) {
	fake.deactivateRegMutex.Lock()
	defer fake.deactivateRegMutex.Unlock()
	fake.DeactivateRegStub = stub
}

func (fake *FakeClientInterface) DeactivateRegArgsForCall(i int) context.Context {
	fake.deactivateRegMutex.RLock()
	defer fake.deactivateRegMutex.RUnlock()
	argsForCall := fake.deactivateRegArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) DeactivateRegReturns(result1 error) {
	fake.deactivateRegMutex.Lock()
	defer fake.deactivateRegMutex.Unlock()
	fake.DeactivateRegStub = nil
	fake.deactivateRegReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClientInterface) DeactivateRegReturnsOnCall(i int, result1 error) {
	fake.deactivateRegMutex.Lock()
	defer fake.deactivateRegMutex.Unlock()
	fake.DeactivateRegStub = nil
	if fake.deactivateRegReturnsOnCall == nil {
		fake.deactivateRegReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deactivateRegReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClientInterface) Discover(arg1 context.Context) (acme.Directory, error) {
	fake.discoverMutex.Lock()
	ret, specificReturn := fake.discoverReturnsOnCall[len(fake.discoverArgsForCall)]
	fake.discoverArgsForCall = append(fake.discoverArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Discover", []interface{}{arg1})
	fake.discoverMutex.Unlock()
	if fake.DiscoverStub != nil {
		return fake.DiscoverStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.discoverReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) DiscoverCallCount() int {
	fake.discoverMutex.RLock()
	defer fake.discoverMutex.RUnlock()
	return len(fake.discoverArgsForCall)
}

func (fake *FakeClientInterface) DiscoverCalls(stub func(context.Context) (acme.Directory, error)) {
	fake.discoverMutex.Lock()
	defer fake.discoverMutex.Unlock()
	fake.DiscoverStub = stub
}

func (fake *FakeClientInterface) DiscoverArgsForCall(i int) context.Context {
	fake.discoverMutex.RLock()
	defer fake.discoverMutex.RUnlock()
	argsForCall := fake.discoverArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) DiscoverReturns(result1 acme.Directory, result2 error) {
	fake.discoverMutex.Lock()
	defer fake.discoverMutex.Unlock()
	fake.DiscoverStub = nil
	fake.discoverReturns = struct {
		result1 acme.Directory
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) DiscoverReturnsOnCall(i int, result1 acme.Directory, result2 error) {
	fake.discoverMutex.Lock()
	defer fake.discoverMutex.Unlock()
	fake.DiscoverStub = nil
	if fake.discoverReturnsOnCall == nil {
		fake.discoverReturnsOnCall = make(map[int]struct {
			result1 acme.Directory
			result2 error
		})
	}
	fake.discoverReturnsOnCall[i] = struct {
		result1 acme.Directory
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) FetchCert(arg1 context.Context, arg2 string, arg3 bool) ([][]byte, error) {
	fake.fetchCertMutex.Lock()
	ret, specificReturn := fake.fetchCertReturnsOnCall[len(fake.fetchCertArgsForCall)]
	fake.fetchCertArgsForCall = append(fake.fetchCertArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("FetchCert", []interface{}{arg1, arg2, arg3})
	fake.fetchCertMutex.Unlock()
	if fake.FetchCertStub != nil {
		return fake.FetchCertStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.fetchCertReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) FetchCertCallCount() int {
	fake.fetchCertMutex.RLock()
	defer fake.fetchCertMutex.RUnlock()
	return len(fake.fetchCertArgsForCall)
}

func (fake *FakeClientInterface) FetchCertCalls(stub func(context.Context, string, bool) ([][]byte, error)) {
	fake.fetchCertMutex.Lock()
	defer fake.fetchCertMutex.Unlock()
	fake.FetchCertStub = stub
}

func (fake *FakeClientInterface) FetchCertArgsForCall(i int) (context.Context, string, bool) {
	fake.fetchCertMutex.RLock()
	defer fake.fetchCertMutex.RUnlock()
	argsForCall := fake.fetchCertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClientInterface) FetchCertReturns(result1 [][]byte, result2 error) {
	fake.fetchCertMutex.Lock()
	defer fake.fetchCertMutex.Unlock()
	fake.FetchCertStub = nil
	fake.fetchCertReturns = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) FetchCertReturnsOnCall(i int, result1 [][]byte, result2 error) {
	fake.fetchCertMutex.Lock()
	defer fake.fetchCertMutex.Unlock()
	fake.FetchCertStub = nil
	if fake.fetchCertReturnsOnCall == nil {
		fake.fetchCertReturnsOnCall = make(map[int]struct {
			result1 [][]byte
			result2 error
		})
	}
	fake.fetchCertReturnsOnCall[i] = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetAuthorization(arg1 context.Context, arg2 string) (*acme.Authorization, error) {
	fake.getAuthorizationMutex.Lock()
	ret, specificReturn := fake.getAuthorizationReturnsOnCall[len(fake.getAuthorizationArgsForCall)]
	fake.getAuthorizationArgsForCall = append(fake.getAuthorizationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetAuthorization", []interface{}{arg1, arg2})
	fake.getAuthorizationMutex.Unlock()
	if fake.GetAuthorizationStub != nil {
		return fake.GetAuthorizationStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAuthorizationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) GetAuthorizationCallCount() int {
	fake.getAuthorizationMutex.RLock()
	defer fake.getAuthorizationMutex.RUnlock()
	return len(fake.getAuthorizationArgsForCall)
}

func (fake *FakeClientInterface) GetAuthorizationCalls(stub func(context.Context, string) (*acme.Authorization, error)) {
	fake.getAuthorizationMutex.Lock()
	defer fake.getAuthorizationMutex.Unlock()
	fake.GetAuthorizationStub = stub
}

func (fake *FakeClientInterface) GetAuthorizationArgsForCall(i int) (context.Context, string) {
	fake.getAuthorizationMutex.RLock()
	defer fake.getAuthorizationMutex.RUnlock()
	argsForCall := fake.getAuthorizationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) GetAuthorizationReturns(result1 *acme.Authorization, result2 error) {
	fake.getAuthorizationMutex.Lock()
	defer fake.getAuthorizationMutex.Unlock()
	fake.GetAuthorizationStub = nil
	fake.getAuthorizationReturns = struct {
		result1 *acme.Authorization
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetAuthorizationReturnsOnCall(i int, result1 *acme.Authorization, result2 error) {
	fake.getAuthorizationMutex.Lock()
	defer fake.getAuthorizationMutex.Unlock()
	fake.GetAuthorizationStub = nil
	if fake.getAuthorizationReturnsOnCall == nil {
		fake.getAuthorizationReturnsOnCall = make(map[int]struct {
			result1 *acme.Authorization
			result2 error
		})
	}
	fake.getAuthorizationReturnsOnCall[i] = struct {
		result1 *acme.Authorization
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetChallenge(arg1 context.Context, arg2 string) (*acme.Challenge, error) {
	fake.getChallengeMutex.Lock()
	ret, specificReturn := fake.getChallengeReturnsOnCall[len(fake.getChallengeArgsForCall)]
	fake.getChallengeArgsForCall = append(fake.getChallengeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetChallenge", []interface{}{arg1, arg2})
	fake.getChallengeMutex.Unlock()
	if fake.GetChallengeStub != nil {
		return fake.GetChallengeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getChallengeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) GetChallengeCallCount() int {
	fake.getChallengeMutex.RLock()
	defer fake.getChallengeMutex.RUnlock()
	return len(fake.getChallengeArgsForCall)
}

func (fake *FakeClientInterface) GetChallengeCalls(stub func(context.Context, string) (*acme.Challenge, error)) {
	fake.getChallengeMutex.Lock()
	defer fake.getChallengeMutex.Unlock()
	fake.GetChallengeStub = stub
}

func (fake *FakeClientInterface) GetChallengeArgsForCall(i int) (context.Context, string) {
	fake.getChallengeMutex.RLock()
	defer fake.getChallengeMutex.RUnlock()
	argsForCall := fake.getChallengeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) GetChallengeReturns(result1 *acme.Challenge, result2 error) {
	fake.getChallengeMutex.Lock()
	defer fake.getChallengeMutex.Unlock()
	fake.GetChallengeStub = nil
	fake.getChallengeReturns = struct {
		result1 *acme.Challenge
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetChallengeReturnsOnCall(i int, result1 *acme.Challenge, result2 error) {
	fake.getChallengeMutex.Lock()
	defer fake.getChallengeMutex.Unlock()
	fake.GetChallengeStub = nil
	if fake.getChallengeReturnsOnCall == nil {
		fake.getChallengeReturnsOnCall = make(map[int]struct {
			result1 *acme.Challenge
			result2 error
		})
	}
	fake.getChallengeReturnsOnCall[i] = struct {
		result1 *acme.Challenge
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetKey() crypto.Signer {
	fake.getKeyMutex.Lock()
	ret, specificReturn := fake.getKeyReturnsOnCall[len(fake.getKeyArgsForCall)]
	fake.getKeyArgsForCall = append(fake.getKeyArgsForCall, struct {
	}{})
	fake.recordInvocation("GetKey", []interface{}{})
	fake.getKeyMutex.Unlock()
	if fake.GetKeyStub != nil {
		return fake.GetKeyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getKeyReturns
	return fakeReturns.result1
}

func (fake *FakeClientInterface) GetKeyCallCount() int {
	fake.getKeyMutex.RLock()
	defer fake.getKeyMutex.RUnlock()
	return len(fake.getKeyArgsForCall)
}

func (fake *FakeClientInterface) GetKeyCalls(stub func() crypto.Signer) {
	fake.getKeyMutex.Lock()
	defer fake.getKeyMutex.Unlock()
	fake.GetKeyStub = stub
}

func (fake *FakeClientInterface) GetKeyReturns(result1 crypto.Signer) {
	fake.getKeyMutex.Lock()
	defer fake.getKeyMutex.Unlock()
	fake.GetKeyStub = nil
	fake.getKeyReturns = struct {
		result1 crypto.Signer
	}{result1}
}

func (fake *FakeClientInterface) GetKeyReturnsOnCall(i int, result1 crypto.Signer) {
	fake.getKeyMutex.Lock()
	defer fake.getKeyMutex.Unlock()
	fake.GetKeyStub = nil
	if fake.getKeyReturnsOnCall == nil {
		fake.getKeyReturnsOnCall = make(map[int]struct {
			result1 crypto.Signer
		})
	}
	fake.getKeyReturnsOnCall[i] = struct {
		result1 crypto.Signer
	}{result1}
}

func (fake *FakeClientInterface) GetOrder(arg1 context.Context, arg2 string) (*acme.Order, error) {
	fake.getOrderMutex.Lock()
	ret, specificReturn := fake.getOrderReturnsOnCall[len(fake.getOrderArgsForCall)]
	fake.getOrderArgsForCall = append(fake.getOrderArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetOrder", []interface{}{arg1, arg2})
	fake.getOrderMutex.Unlock()
	if fake.GetOrderStub != nil {
		return fake.GetOrderStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getOrderReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) GetOrderCallCount() int {
	fake.getOrderMutex.RLock()
	defer fake.getOrderMutex.RUnlock()
	return len(fake.getOrderArgsForCall)
}

func (fake *FakeClientInterface) GetOrderCalls(stub func(context.Context, string) (*acme.Order, error)) {
	fake.getOrderMutex.Lock()
	defer fake.getOrderMutex.Unlock()
	fake.GetOrderStub = stub
}

func (fake *FakeClientInterface) GetOrderArgsForCall(i int) (context.Context, string) {
	fake.getOrderMutex.RLock()
	defer fake.getOrderMutex.RUnlock()
	argsForCall := fake.getOrderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) GetOrderReturns(result1 *acme.Order, result2 error) {
	fake.getOrderMutex.Lock()
	defer fake.getOrderMutex.Unlock()
	fake.GetOrderStub = nil
	fake.getOrderReturns = struct {
		result1 *acme.Order
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetOrderReturnsOnCall(i int, result1 *acme.Order, result2 error) {
	fake.getOrderMutex.Lock()
	defer fake.getOrderMutex.Unlock()
	fake.GetOrderStub = nil
	if fake.getOrderReturnsOnCall == nil {
		fake.getOrderReturnsOnCall = make(map[int]struct {
			result1 *acme.Order
			result2 error
		})
	}
	fake.getOrderReturnsOnCall[i] = struct {
		result1 *acme.Order
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetReg(arg1 context.Context, arg2 string) (*acme.Account, error) {
	fake.getRegMutex.Lock()
	ret, specificReturn := fake.getRegReturnsOnCall[len(fake.getRegArgsForCall)]
	fake.getRegArgsForCall = append(fake.getRegArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetReg", []interface{}{arg1, arg2})
	fake.getRegMutex.Unlock()
	if fake.GetRegStub != nil {
		return fake.GetRegStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getRegReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) GetRegCallCount() int {
	fake.getRegMutex.RLock()
	defer fake.getRegMutex.RUnlock()
	return len(fake.getRegArgsForCall)
}

func (fake *FakeClientInterface) GetRegCalls(stub func(context.Context, string) (*acme.Account, error)) {
	fake.getRegMutex.Lock()
	defer fake.getRegMutex.Unlock()
	fake.GetRegStub = stub
}

func (fake *FakeClientInterface) GetRegArgsForCall(i int) (context.Context, string) {
	fake.getRegMutex.RLock()
	defer fake.getRegMutex.RUnlock()
	argsForCall := fake.getRegArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) GetRegReturns(result1 *acme.Account, result2 error) {
	fake.getRegMutex.Lock()
	defer fake.getRegMutex.Unlock()
	fake.GetRegStub = nil
	fake.getRegReturns = struct {
		result1 *acme.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) GetRegReturnsOnCall(i int, result1 *acme.Account, result2 error) {
	fake.getRegMutex.Lock()
	defer fake.getRegMutex.Unlock()
	fake.GetRegStub = nil
	if fake.getRegReturnsOnCall == nil {
		fake.getRegReturnsOnCall = make(map[int]struct {
			result1 *acme.Account
			result2 error
		})
	}
	fake.getRegReturnsOnCall[i] = struct {
		result1 *acme.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) HTTP01ChallengePath(arg1 string) string {
	fake.hTTP01ChallengePathMutex.Lock()
	ret, specificReturn := fake.hTTP01ChallengePathReturnsOnCall[len(fake.hTTP01ChallengePathArgsForCall)]
	fake.hTTP01ChallengePathArgsForCall = append(fake.hTTP01ChallengePathArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("HTTP01ChallengePath", []interface{}{arg1})
	fake.hTTP01ChallengePathMutex.Unlock()
	if fake.HTTP01ChallengePathStub != nil {
		return fake.HTTP01ChallengePathStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hTTP01ChallengePathReturns
	return fakeReturns.result1
}

func (fake *FakeClientInterface) HTTP01ChallengePathCallCount() int {
	fake.hTTP01ChallengePathMutex.RLock()
	defer fake.hTTP01ChallengePathMutex.RUnlock()
	return len(fake.hTTP01ChallengePathArgsForCall)
}

func (fake *FakeClientInterface) HTTP01ChallengePathCalls(stub func(string) string) {
	fake.hTTP01ChallengePathMutex.Lock()
	defer fake.hTTP01ChallengePathMutex.Unlock()
	fake.HTTP01ChallengePathStub = stub
}

func (fake *FakeClientInterface) HTTP01ChallengePathArgsForCall(i int) string {
	fake.hTTP01ChallengePathMutex.RLock()
	defer fake.hTTP01ChallengePathMutex.RUnlock()
	argsForCall := fake.hTTP01ChallengePathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) HTTP01ChallengePathReturns(result1 string) {
	fake.hTTP01ChallengePathMutex.Lock()
	defer fake.hTTP01ChallengePathMutex.Unlock()
	fake.HTTP01ChallengePathStub = nil
	fake.hTTP01ChallengePathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClientInterface) HTTP01ChallengePathReturnsOnCall(i int, result1 string) {
	fake.hTTP01ChallengePathMutex.Lock()
	defer fake.hTTP01ChallengePathMutex.Unlock()
	fake.HTTP01ChallengePathStub = nil
	if fake.hTTP01ChallengePathReturnsOnCall == nil {
		fake.hTTP01ChallengePathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.hTTP01ChallengePathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClientInterface) HTTP01ChallengeResponse(arg1 string) (string, error) {
	fake.hTTP01ChallengeResponseMutex.Lock()
	ret, specificReturn := fake.hTTP01ChallengeResponseReturnsOnCall[len(fake.hTTP01ChallengeResponseArgsForCall)]
	fake.hTTP01ChallengeResponseArgsForCall = append(fake.hTTP01ChallengeResponseArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("HTTP01ChallengeResponse", []interface{}{arg1})
	fake.hTTP01ChallengeResponseMutex.Unlock()
	if fake.HTTP01ChallengeResponseStub != nil {
		return fake.HTTP01ChallengeResponseStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.hTTP01ChallengeResponseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) HTTP01ChallengeResponseCallCount() int {
	fake.hTTP01ChallengeResponseMutex.RLock()
	defer fake.hTTP01ChallengeResponseMutex.RUnlock()
	return len(fake.hTTP01ChallengeResponseArgsForCall)
}

func (fake *FakeClientInterface) HTTP01ChallengeResponseCalls(stub func(string) (string, error)) {
	fake.hTTP01ChallengeResponseMutex.Lock()
	defer fake.hTTP01ChallengeResponseMutex.Unlock()
	fake.HTTP01ChallengeResponseStub = stub
}

func (fake *FakeClientInterface) HTTP01ChallengeResponseArgsForCall(i int) string {
	fake.hTTP01ChallengeResponseMutex.RLock()
	defer fake.hTTP01ChallengeResponseMutex.RUnlock()
	argsForCall := fake.hTTP01ChallengeResponseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientInterface) HTTP01ChallengeResponseReturns(result1 string, result2 error) {
	fake.hTTP01ChallengeResponseMutex.Lock()
	defer fake.hTTP01ChallengeResponseMutex.Unlock()
	fake.HTTP01ChallengeResponseStub = nil
	fake.hTTP01ChallengeResponseReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) HTTP01ChallengeResponseReturnsOnCall(i int, result1 string, result2 error) {
	fake.hTTP01ChallengeResponseMutex.Lock()
	defer fake.hTTP01ChallengeResponseMutex.Unlock()
	fake.HTTP01ChallengeResponseStub = nil
	if fake.hTTP01ChallengeResponseReturnsOnCall == nil {
		fake.hTTP01ChallengeResponseReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.hTTP01ChallengeResponseReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) Register(arg1 context.Context, arg2 *acme.Account, arg3 func(tosURL string) bool) (*acme.Account, error) {
	fake.registerMutex.Lock()
	ret, specificReturn := fake.registerReturnsOnCall[len(fake.registerArgsForCall)]
	fake.registerArgsForCall = append(fake.registerArgsForCall, struct {
		arg1 context.Context
		arg2 *acme.Account
		arg3 func(tosURL string) bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("Register", []interface{}{arg1, arg2, arg3})
	fake.registerMutex.Unlock()
	if fake.RegisterStub != nil {
		return fake.RegisterStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.registerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) RegisterCallCount() int {
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	return len(fake.registerArgsForCall)
}

func (fake *FakeClientInterface) RegisterCalls(stub func(context.Context, *acme.Account, func(tosURL string) bool) (*acme.Account, error)) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = stub
}

func (fake *FakeClientInterface) RegisterArgsForCall(i int) (context.Context, *acme.Account, func(tosURL string) bool) {
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	argsForCall := fake.registerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClientInterface) RegisterReturns(result1 *acme.Account, result2 error) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = nil
	fake.registerReturns = struct {
		result1 *acme.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) RegisterReturnsOnCall(i int, result1 *acme.Account, result2 error) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = nil
	if fake.registerReturnsOnCall == nil {
		fake.registerReturnsOnCall = make(map[int]struct {
			result1 *acme.Account
			result2 error
		})
	}
	fake.registerReturnsOnCall[i] = struct {
		result1 *acme.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) RevokeAuthorization(arg1 context.Context, arg2 string) error {
	fake.revokeAuthorizationMutex.Lock()
	ret, specificReturn := fake.revokeAuthorizationReturnsOnCall[len(fake.revokeAuthorizationArgsForCall)]
	fake.revokeAuthorizationArgsForCall = append(fake.revokeAuthorizationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RevokeAuthorization", []interface{}{arg1, arg2})
	fake.revokeAuthorizationMutex.Unlock()
	if fake.RevokeAuthorizationStub != nil {
		return fake.RevokeAuthorizationStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.revokeAuthorizationReturns
	return fakeReturns.result1
}

func (fake *FakeClientInterface) RevokeAuthorizationCallCount() int {
	fake.revokeAuthorizationMutex.RLock()
	defer fake.revokeAuthorizationMutex.RUnlock()
	return len(fake.revokeAuthorizationArgsForCall)
}

func (fake *FakeClientInterface) RevokeAuthorizationCalls(stub func(context.Context, string) error) {
	fake.revokeAuthorizationMutex.Lock()
	defer fake.revokeAuthorizationMutex.Unlock()
	fake.RevokeAuthorizationStub = stub
}

func (fake *FakeClientInterface) RevokeAuthorizationArgsForCall(i int) (context.Context, string) {
	fake.revokeAuthorizationMutex.RLock()
	defer fake.revokeAuthorizationMutex.RUnlock()
	argsForCall := fake.revokeAuthorizationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) RevokeAuthorizationReturns(result1 error) {
	fake.revokeAuthorizationMutex.Lock()
	defer fake.revokeAuthorizationMutex.Unlock()
	fake.RevokeAuthorizationStub = nil
	fake.revokeAuthorizationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClientInterface) RevokeAuthorizationReturnsOnCall(i int, result1 error) {
	fake.revokeAuthorizationMutex.Lock()
	defer fake.revokeAuthorizationMutex.Unlock()
	fake.RevokeAuthorizationStub = nil
	if fake.revokeAuthorizationReturnsOnCall == nil {
		fake.revokeAuthorizationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.revokeAuthorizationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClientInterface) RevokeCert(arg1 context.Context, arg2 crypto.Signer, arg3 []byte, arg4 acme.CRLReasonCode) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.revokeCertMutex.Lock()
	ret, specificReturn := fake.revokeCertReturnsOnCall[len(fake.revokeCertArgsForCall)]
	fake.revokeCertArgsForCall = append(fake.revokeCertArgsForCall, struct {
		arg1 context.Context
		arg2 crypto.Signer
		arg3 []byte
		arg4 acme.CRLReasonCode
	}{arg1, arg2, arg3Copy, arg4})
	fake.recordInvocation("RevokeCert", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.revokeCertMutex.Unlock()
	if fake.RevokeCertStub != nil {
		return fake.RevokeCertStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.revokeCertReturns
	return fakeReturns.result1
}

func (fake *FakeClientInterface) RevokeCertCallCount() int {
	fake.revokeCertMutex.RLock()
	defer fake.revokeCertMutex.RUnlock()
	return len(fake.revokeCertArgsForCall)
}

func (fake *FakeClientInterface) RevokeCertCalls(stub func(context.Context, crypto.Signer, []byte, acme.CRLReasonCode) error) {
	fake.revokeCertMutex.Lock()
	defer fake.revokeCertMutex.Unlock()
	fake.RevokeCertStub = stub
}

func (fake *FakeClientInterface) RevokeCertArgsForCall(i int) (context.Context, crypto.Signer, []byte, acme.CRLReasonCode) {
	fake.revokeCertMutex.RLock()
	defer fake.revokeCertMutex.RUnlock()
	argsForCall := fake.revokeCertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClientInterface) RevokeCertReturns(result1 error) {
	fake.revokeCertMutex.Lock()
	defer fake.revokeCertMutex.Unlock()
	fake.RevokeCertStub = nil
	fake.revokeCertReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClientInterface) RevokeCertReturnsOnCall(i int, result1 error) {
	fake.revokeCertMutex.Lock()
	defer fake.revokeCertMutex.Unlock()
	fake.RevokeCertStub = nil
	if fake.revokeCertReturnsOnCall == nil {
		fake.revokeCertReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.revokeCertReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClientInterface) TLSALPN01ChallengeCert(arg1 string, arg2 string, arg3 ...acme.CertOption) (tls.Certificate, error) {
	fake.tLSALPN01ChallengeCertMutex.Lock()
	ret, specificReturn := fake.tLSALPN01ChallengeCertReturnsOnCall[len(fake.tLSALPN01ChallengeCertArgsForCall)]
	fake.tLSALPN01ChallengeCertArgsForCall = append(fake.tLSALPN01ChallengeCertArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []acme.CertOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("TLSALPN01ChallengeCert", []interface{}{arg1, arg2, arg3})
	fake.tLSALPN01ChallengeCertMutex.Unlock()
	if fake.TLSALPN01ChallengeCertStub != nil {
		return fake.TLSALPN01ChallengeCertStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tLSALPN01ChallengeCertReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) TLSALPN01ChallengeCertCallCount() int {
	fake.tLSALPN01ChallengeCertMutex.RLock()
	defer fake.tLSALPN01ChallengeCertMutex.RUnlock()
	return len(fake.tLSALPN01ChallengeCertArgsForCall)
}

func (fake *FakeClientInterface) TLSALPN01ChallengeCertCalls(stub func(string, string, ...acme.CertOption) (tls.Certificate, error)) {
	fake.tLSALPN01ChallengeCertMutex.Lock()
	defer fake.tLSALPN01ChallengeCertMutex.Unlock()
	fake.TLSALPN01ChallengeCertStub = stub
}

func (fake *FakeClientInterface) TLSALPN01ChallengeCertArgsForCall(i int) (string, string, []acme.CertOption) {
	fake.tLSALPN01ChallengeCertMutex.RLock()
	defer fake.tLSALPN01ChallengeCertMutex.RUnlock()
	argsForCall := fake.tLSALPN01ChallengeCertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClientInterface) TLSALPN01ChallengeCertReturns(result1 tls.Certificate, result2 error) {
	fake.tLSALPN01ChallengeCertMutex.Lock()
	defer fake.tLSALPN01ChallengeCertMutex.Unlock()
	fake.TLSALPN01ChallengeCertStub = nil
	fake.tLSALPN01ChallengeCertReturns = struct {
		result1 tls.Certificate
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) TLSALPN01ChallengeCertReturnsOnCall(i int, result1 tls.Certificate, result2 error) {
	fake.tLSALPN01ChallengeCertMutex.Lock()
	defer fake.tLSALPN01ChallengeCertMutex.Unlock()
	fake.TLSALPN01ChallengeCertStub = nil
	if fake.tLSALPN01ChallengeCertReturnsOnCall == nil {
		fake.tLSALPN01ChallengeCertReturnsOnCall = make(map[int]struct {
			result1 tls.Certificate
			result2 error
		})
	}
	fake.tLSALPN01ChallengeCertReturnsOnCall[i] = struct {
		result1 tls.Certificate
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) TLSSNI01ChallengeCert(arg1 string, arg2 ...acme.CertOption) (tls.Certificate, string, error) {
	fake.tLSSNI01ChallengeCertMutex.Lock()
	ret, specificReturn := fake.tLSSNI01ChallengeCertReturnsOnCall[len(fake.tLSSNI01ChallengeCertArgsForCall)]
	fake.tLSSNI01ChallengeCertArgsForCall = append(fake.tLSSNI01ChallengeCertArgsForCall, struct {
		arg1 string
		arg2 []acme.CertOption
	}{arg1, arg2})
	fake.recordInvocation("TLSSNI01ChallengeCert", []interface{}{arg1, arg2})
	fake.tLSSNI01ChallengeCertMutex.Unlock()
	if fake.TLSSNI01ChallengeCertStub != nil {
		return fake.TLSSNI01ChallengeCertStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.tLSSNI01ChallengeCertReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientInterface) TLSSNI01ChallengeCertCallCount() int {
	fake.tLSSNI01ChallengeCertMutex.RLock()
	defer fake.tLSSNI01ChallengeCertMutex.RUnlock()
	return len(fake.tLSSNI01ChallengeCertArgsForCall)
}

func (fake *FakeClientInterface) TLSSNI01ChallengeCertCalls(stub func(string, ...acme.CertOption) (tls.Certificate, string, error)) {
	fake.tLSSNI01ChallengeCertMutex.Lock()
	defer fake.tLSSNI01ChallengeCertMutex.Unlock()
	fake.TLSSNI01ChallengeCertStub = stub
}

func (fake *FakeClientInterface) TLSSNI01ChallengeCertArgsForCall(i int) (string, []acme.CertOption) {
	fake.tLSSNI01ChallengeCertMutex.RLock()
	defer fake.tLSSNI01ChallengeCertMutex.RUnlock()
	argsForCall := fake.tLSSNI01ChallengeCertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) TLSSNI01ChallengeCertReturns(result1 tls.Certificate, result2 string, result3 error) {
	fake.tLSSNI01ChallengeCertMutex.Lock()
	defer fake.tLSSNI01ChallengeCertMutex.Unlock()
	fake.TLSSNI01ChallengeCertStub = nil
	fake.tLSSNI01ChallengeCertReturns = struct {
		result1 tls.Certificate
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientInterface) TLSSNI01ChallengeCertReturnsOnCall(i int, result1 tls.Certificate, result2 string, result3 error) {
	fake.tLSSNI01ChallengeCertMutex.Lock()
	defer fake.tLSSNI01ChallengeCertMutex.Unlock()
	fake.TLSSNI01ChallengeCertStub = nil
	if fake.tLSSNI01ChallengeCertReturnsOnCall == nil {
		fake.tLSSNI01ChallengeCertReturnsOnCall = make(map[int]struct {
			result1 tls.Certificate
			result2 string
			result3 error
		})
	}
	fake.tLSSNI01ChallengeCertReturnsOnCall[i] = struct {
		result1 tls.Certificate
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientInterface) TLSSNI02ChallengeCert(arg1 string, arg2 ...acme.CertOption) (tls.Certificate, string, error) {
	fake.tLSSNI02ChallengeCertMutex.Lock()
	ret, specificReturn := fake.tLSSNI02ChallengeCertReturnsOnCall[len(fake.tLSSNI02ChallengeCertArgsForCall)]
	fake.tLSSNI02ChallengeCertArgsForCall = append(fake.tLSSNI02ChallengeCertArgsForCall, struct {
		arg1 string
		arg2 []acme.CertOption
	}{arg1, arg2})
	fake.recordInvocation("TLSSNI02ChallengeCert", []interface{}{arg1, arg2})
	fake.tLSSNI02ChallengeCertMutex.Unlock()
	if fake.TLSSNI02ChallengeCertStub != nil {
		return fake.TLSSNI02ChallengeCertStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.tLSSNI02ChallengeCertReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientInterface) TLSSNI02ChallengeCertCallCount() int {
	fake.tLSSNI02ChallengeCertMutex.RLock()
	defer fake.tLSSNI02ChallengeCertMutex.RUnlock()
	return len(fake.tLSSNI02ChallengeCertArgsForCall)
}

func (fake *FakeClientInterface) TLSSNI02ChallengeCertCalls(stub func(string, ...acme.CertOption) (tls.Certificate, string, error)) {
	fake.tLSSNI02ChallengeCertMutex.Lock()
	defer fake.tLSSNI02ChallengeCertMutex.Unlock()
	fake.TLSSNI02ChallengeCertStub = stub
}

func (fake *FakeClientInterface) TLSSNI02ChallengeCertArgsForCall(i int) (string, []acme.CertOption) {
	fake.tLSSNI02ChallengeCertMutex.RLock()
	defer fake.tLSSNI02ChallengeCertMutex.RUnlock()
	argsForCall := fake.tLSSNI02ChallengeCertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) TLSSNI02ChallengeCertReturns(result1 tls.Certificate, result2 string, result3 error) {
	fake.tLSSNI02ChallengeCertMutex.Lock()
	defer fake.tLSSNI02ChallengeCertMutex.Unlock()
	fake.TLSSNI02ChallengeCertStub = nil
	fake.tLSSNI02ChallengeCertReturns = struct {
		result1 tls.Certificate
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientInterface) TLSSNI02ChallengeCertReturnsOnCall(i int, result1 tls.Certificate, result2 string, result3 error) {
	fake.tLSSNI02ChallengeCertMutex.Lock()
	defer fake.tLSSNI02ChallengeCertMutex.Unlock()
	fake.TLSSNI02ChallengeCertStub = nil
	if fake.tLSSNI02ChallengeCertReturnsOnCall == nil {
		fake.tLSSNI02ChallengeCertReturnsOnCall = make(map[int]struct {
			result1 tls.Certificate
			result2 string
			result3 error
		})
	}
	fake.tLSSNI02ChallengeCertReturnsOnCall[i] = struct {
		result1 tls.Certificate
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientInterface) UpdateReg(arg1 context.Context, arg2 *acme.Account) (*acme.Account, error) {
	fake.updateRegMutex.Lock()
	ret, specificReturn := fake.updateRegReturnsOnCall[len(fake.updateRegArgsForCall)]
	fake.updateRegArgsForCall = append(fake.updateRegArgsForCall, struct {
		arg1 context.Context
		arg2 *acme.Account
	}{arg1, arg2})
	fake.recordInvocation("UpdateReg", []interface{}{arg1, arg2})
	fake.updateRegMutex.Unlock()
	if fake.UpdateRegStub != nil {
		return fake.UpdateRegStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateRegReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) UpdateRegCallCount() int {
	fake.updateRegMutex.RLock()
	defer fake.updateRegMutex.RUnlock()
	return len(fake.updateRegArgsForCall)
}

func (fake *FakeClientInterface) UpdateRegCalls(stub func(context.Context, *acme.Account) (*acme.Account, error)) {
	fake.updateRegMutex.Lock()
	defer fake.updateRegMutex.Unlock()
	fake.UpdateRegStub = stub
}

func (fake *FakeClientInterface) UpdateRegArgsForCall(i int) (context.Context, *acme.Account) {
	fake.updateRegMutex.RLock()
	defer fake.updateRegMutex.RUnlock()
	argsForCall := fake.updateRegArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) UpdateRegReturns(result1 *acme.Account, result2 error) {
	fake.updateRegMutex.Lock()
	defer fake.updateRegMutex.Unlock()
	fake.UpdateRegStub = nil
	fake.updateRegReturns = struct {
		result1 *acme.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) UpdateRegReturnsOnCall(i int, result1 *acme.Account, result2 error) {
	fake.updateRegMutex.Lock()
	defer fake.updateRegMutex.Unlock()
	fake.UpdateRegStub = nil
	if fake.updateRegReturnsOnCall == nil {
		fake.updateRegReturnsOnCall = make(map[int]struct {
			result1 *acme.Account
			result2 error
		})
	}
	fake.updateRegReturnsOnCall[i] = struct {
		result1 *acme.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) WaitAuthorization(arg1 context.Context, arg2 string) (*acme.Authorization, error) {
	fake.waitAuthorizationMutex.Lock()
	ret, specificReturn := fake.waitAuthorizationReturnsOnCall[len(fake.waitAuthorizationArgsForCall)]
	fake.waitAuthorizationArgsForCall = append(fake.waitAuthorizationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("WaitAuthorization", []interface{}{arg1, arg2})
	fake.waitAuthorizationMutex.Unlock()
	if fake.WaitAuthorizationStub != nil {
		return fake.WaitAuthorizationStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.waitAuthorizationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) WaitAuthorizationCallCount() int {
	fake.waitAuthorizationMutex.RLock()
	defer fake.waitAuthorizationMutex.RUnlock()
	return len(fake.waitAuthorizationArgsForCall)
}

func (fake *FakeClientInterface) WaitAuthorizationCalls(stub func(context.Context, string) (*acme.Authorization, error)) {
	fake.waitAuthorizationMutex.Lock()
	defer fake.waitAuthorizationMutex.Unlock()
	fake.WaitAuthorizationStub = stub
}

func (fake *FakeClientInterface) WaitAuthorizationArgsForCall(i int) (context.Context, string) {
	fake.waitAuthorizationMutex.RLock()
	defer fake.waitAuthorizationMutex.RUnlock()
	argsForCall := fake.waitAuthorizationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) WaitAuthorizationReturns(result1 *acme.Authorization, result2 error) {
	fake.waitAuthorizationMutex.Lock()
	defer fake.waitAuthorizationMutex.Unlock()
	fake.WaitAuthorizationStub = nil
	fake.waitAuthorizationReturns = struct {
		result1 *acme.Authorization
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) WaitAuthorizationReturnsOnCall(i int, result1 *acme.Authorization, result2 error) {
	fake.waitAuthorizationMutex.Lock()
	defer fake.waitAuthorizationMutex.Unlock()
	fake.WaitAuthorizationStub = nil
	if fake.waitAuthorizationReturnsOnCall == nil {
		fake.waitAuthorizationReturnsOnCall = make(map[int]struct {
			result1 *acme.Authorization
			result2 error
		})
	}
	fake.waitAuthorizationReturnsOnCall[i] = struct {
		result1 *acme.Authorization
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) WaitOrder(arg1 context.Context, arg2 string) (*acme.Order, error) {
	fake.waitOrderMutex.Lock()
	ret, specificReturn := fake.waitOrderReturnsOnCall[len(fake.waitOrderArgsForCall)]
	fake.waitOrderArgsForCall = append(fake.waitOrderArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("WaitOrder", []interface{}{arg1, arg2})
	fake.waitOrderMutex.Unlock()
	if fake.WaitOrderStub != nil {
		return fake.WaitOrderStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.waitOrderReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientInterface) WaitOrderCallCount() int {
	fake.waitOrderMutex.RLock()
	defer fake.waitOrderMutex.RUnlock()
	return len(fake.waitOrderArgsForCall)
}

func (fake *FakeClientInterface) WaitOrderCalls(stub func(context.Context, string) (*acme.Order, error)) {
	fake.waitOrderMutex.Lock()
	defer fake.waitOrderMutex.Unlock()
	fake.WaitOrderStub = stub
}

func (fake *FakeClientInterface) WaitOrderArgsForCall(i int) (context.Context, string) {
	fake.waitOrderMutex.RLock()
	defer fake.waitOrderMutex.RUnlock()
	argsForCall := fake.waitOrderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientInterface) WaitOrderReturns(result1 *acme.Order, result2 error) {
	fake.waitOrderMutex.Lock()
	defer fake.waitOrderMutex.Unlock()
	fake.WaitOrderStub = nil
	fake.waitOrderReturns = struct {
		result1 *acme.Order
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) WaitOrderReturnsOnCall(i int, result1 *acme.Order, result2 error) {
	fake.waitOrderMutex.Lock()
	defer fake.waitOrderMutex.Unlock()
	fake.WaitOrderStub = nil
	if fake.waitOrderReturnsOnCall == nil {
		fake.waitOrderReturnsOnCall = make(map[int]struct {
			result1 *acme.Order
			result2 error
		})
	}
	fake.waitOrderReturnsOnCall[i] = struct {
		result1 *acme.Order
		result2 error
	}{result1, result2}
}

func (fake *FakeClientInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	fake.authorizeMutex.RLock()
	defer fake.authorizeMutex.RUnlock()
	fake.authorizeIPMutex.RLock()
	defer fake.authorizeIPMutex.RUnlock()
	fake.authorizeOrderMutex.RLock()
	defer fake.authorizeOrderMutex.RUnlock()
	fake.createCertMutex.RLock()
	defer fake.createCertMutex.RUnlock()
	fake.createOrderCertMutex.RLock()
	defer fake.createOrderCertMutex.RUnlock()
	fake.dNS01ChallengeRecordMutex.RLock()
	defer fake.dNS01ChallengeRecordMutex.RUnlock()
	fake.deactivateRegMutex.RLock()
	defer fake.deactivateRegMutex.RUnlock()
	fake.discoverMutex.RLock()
	defer fake.discoverMutex.RUnlock()
	fake.fetchCertMutex.RLock()
	defer fake.fetchCertMutex.RUnlock()
	fake.getAuthorizationMutex.RLock()
	defer fake.getAuthorizationMutex.RUnlock()
	fake.getChallengeMutex.RLock()
	defer fake.getChallengeMutex.RUnlock()
	fake.getKeyMutex.RLock()
	defer fake.getKeyMutex.RUnlock()
	fake.getOrderMutex.RLock()
	defer fake.getOrderMutex.RUnlock()
	fake.getRegMutex.RLock()
	defer fake.getRegMutex.RUnlock()
	fake.hTTP01ChallengePathMutex.RLock()
	defer fake.hTTP01ChallengePathMutex.RUnlock()
	fake.hTTP01ChallengeResponseMutex.RLock()
	defer fake.hTTP01ChallengeResponseMutex.RUnlock()
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	fake.revokeAuthorizationMutex.RLock()
	defer fake.revokeAuthorizationMutex.RUnlock()
	fake.revokeCertMutex.RLock()
	defer fake.revokeCertMutex.RUnlock()
	fake.tLSALPN01ChallengeCertMutex.RLock()
	defer fake.tLSALPN01ChallengeCertMutex.RUnlock()
	fake.tLSSNI01ChallengeCertMutex.RLock()
	defer fake.tLSSNI01ChallengeCertMutex.RUnlock()
	fake.tLSSNI02ChallengeCertMutex.RLock()
	defer fake.tLSSNI02ChallengeCertMutex.RUnlock()
	fake.updateRegMutex.RLock()
	defer fake.updateRegMutex.RUnlock()
	fake.waitAuthorizationMutex.RLock()
	defer fake.waitAuthorizationMutex.RUnlock()
	fake.waitOrderMutex.RLock()
	defer fake.waitOrderMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClientInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ letsencrypt.ClientInterface = new(FakeClientInterface)
