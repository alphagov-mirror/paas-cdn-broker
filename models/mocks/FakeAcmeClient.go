// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"crypto"
	"crypto/x509"
	"sync"

	"github.com/alphagov/paas-cdn-broker/lego/acme"
)

type FakeAcmeClient struct {
	AgreeToTOSStub        func() error
	agreeToTOSMutex       sync.RWMutex
	agreeToTOSArgsForCall []struct {
	}
	agreeToTOSReturns struct {
		result1 error
	}
	agreeToTOSReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRegistrationStub        func() error
	deleteRegistrationMutex       sync.RWMutex
	deleteRegistrationArgsForCall []struct {
	}
	deleteRegistrationReturns struct {
		result1 error
	}
	deleteRegistrationReturnsOnCall map[int]struct {
		result1 error
	}
	ExcludeChallengesStub        func([]acme.Challenge)
	excludeChallengesMutex       sync.RWMutex
	excludeChallengesArgsForCall []struct {
		arg1 []acme.Challenge
	}
	GetChallengesStub        func([]string) ([]acme.AuthorizationResource, map[string]error)
	getChallengesMutex       sync.RWMutex
	getChallengesArgsForCall []struct {
		arg1 []string
	}
	getChallengesReturns struct {
		result1 []acme.AuthorizationResource
		result2 map[string]error
	}
	getChallengesReturnsOnCall map[int]struct {
		result1 []acme.AuthorizationResource
		result2 map[string]error
	}
	ObtainCertificateStub        func([]string, bool, crypto.PrivateKey, bool) (acme.CertificateResource, map[string]error)
	obtainCertificateMutex       sync.RWMutex
	obtainCertificateArgsForCall []struct {
		arg1 []string
		arg2 bool
		arg3 crypto.PrivateKey
		arg4 bool
	}
	obtainCertificateReturns struct {
		result1 acme.CertificateResource
		result2 map[string]error
	}
	obtainCertificateReturnsOnCall map[int]struct {
		result1 acme.CertificateResource
		result2 map[string]error
	}
	ObtainCertificateForCSRStub        func(x509.CertificateRequest, bool) (acme.CertificateResource, map[string]error)
	obtainCertificateForCSRMutex       sync.RWMutex
	obtainCertificateForCSRArgsForCall []struct {
		arg1 x509.CertificateRequest
		arg2 bool
	}
	obtainCertificateForCSRReturns struct {
		result1 acme.CertificateResource
		result2 map[string]error
	}
	obtainCertificateForCSRReturnsOnCall map[int]struct {
		result1 acme.CertificateResource
		result2 map[string]error
	}
	QueryRegistrationStub        func() (*acme.RegistrationResource, error)
	queryRegistrationMutex       sync.RWMutex
	queryRegistrationArgsForCall []struct {
	}
	queryRegistrationReturns struct {
		result1 *acme.RegistrationResource
		result2 error
	}
	queryRegistrationReturnsOnCall map[int]struct {
		result1 *acme.RegistrationResource
		result2 error
	}
	RegisterStub        func() (*acme.RegistrationResource, error)
	registerMutex       sync.RWMutex
	registerArgsForCall []struct {
	}
	registerReturns struct {
		result1 *acme.RegistrationResource
		result2 error
	}
	registerReturnsOnCall map[int]struct {
		result1 *acme.RegistrationResource
		result2 error
	}
	RenewCertificateStub        func(acme.CertificateResource, bool, bool) (acme.CertificateResource, error)
	renewCertificateMutex       sync.RWMutex
	renewCertificateArgsForCall []struct {
		arg1 acme.CertificateResource
		arg2 bool
		arg3 bool
	}
	renewCertificateReturns struct {
		result1 acme.CertificateResource
		result2 error
	}
	renewCertificateReturnsOnCall map[int]struct {
		result1 acme.CertificateResource
		result2 error
	}
	RequestCertificateStub        func([]acme.AuthorizationResource, bool, crypto.PrivateKey, bool) (acme.CertificateResource, error)
	requestCertificateMutex       sync.RWMutex
	requestCertificateArgsForCall []struct {
		arg1 []acme.AuthorizationResource
		arg2 bool
		arg3 crypto.PrivateKey
		arg4 bool
	}
	requestCertificateReturns struct {
		result1 acme.CertificateResource
		result2 error
	}
	requestCertificateReturnsOnCall map[int]struct {
		result1 acme.CertificateResource
		result2 error
	}
	RevokeCertificateStub        func([]byte) error
	revokeCertificateMutex       sync.RWMutex
	revokeCertificateArgsForCall []struct {
		arg1 []byte
	}
	revokeCertificateReturns struct {
		result1 error
	}
	revokeCertificateReturnsOnCall map[int]struct {
		result1 error
	}
	SetChallengeProviderStub        func(acme.Challenge, acme.ChallengeProvider) error
	setChallengeProviderMutex       sync.RWMutex
	setChallengeProviderArgsForCall []struct {
		arg1 acme.Challenge
		arg2 acme.ChallengeProvider
	}
	setChallengeProviderReturns struct {
		result1 error
	}
	setChallengeProviderReturnsOnCall map[int]struct {
		result1 error
	}
	SetHTTPAddressStub        func(string) error
	setHTTPAddressMutex       sync.RWMutex
	setHTTPAddressArgsForCall []struct {
		arg1 string
	}
	setHTTPAddressReturns struct {
		result1 error
	}
	setHTTPAddressReturnsOnCall map[int]struct {
		result1 error
	}
	SetTLSAddressStub        func(string) error
	setTLSAddressMutex       sync.RWMutex
	setTLSAddressArgsForCall []struct {
		arg1 string
	}
	setTLSAddressReturns struct {
		result1 error
	}
	setTLSAddressReturnsOnCall map[int]struct {
		result1 error
	}
	SolveChallengesStub        func([]acme.AuthorizationResource) map[string]error
	solveChallengesMutex       sync.RWMutex
	solveChallengesArgsForCall []struct {
		arg1 []acme.AuthorizationResource
	}
	solveChallengesReturns struct {
		result1 map[string]error
	}
	solveChallengesReturnsOnCall map[int]struct {
		result1 map[string]error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAcmeClient) AgreeToTOS() error {
	fake.agreeToTOSMutex.Lock()
	ret, specificReturn := fake.agreeToTOSReturnsOnCall[len(fake.agreeToTOSArgsForCall)]
	fake.agreeToTOSArgsForCall = append(fake.agreeToTOSArgsForCall, struct {
	}{})
	fake.recordInvocation("AgreeToTOS", []interface{}{})
	fake.agreeToTOSMutex.Unlock()
	if fake.AgreeToTOSStub != nil {
		return fake.AgreeToTOSStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.agreeToTOSReturns
	return fakeReturns.result1
}

func (fake *FakeAcmeClient) AgreeToTOSCallCount() int {
	fake.agreeToTOSMutex.RLock()
	defer fake.agreeToTOSMutex.RUnlock()
	return len(fake.agreeToTOSArgsForCall)
}

func (fake *FakeAcmeClient) AgreeToTOSCalls(stub func() error) {
	fake.agreeToTOSMutex.Lock()
	defer fake.agreeToTOSMutex.Unlock()
	fake.AgreeToTOSStub = stub
}

func (fake *FakeAcmeClient) AgreeToTOSReturns(result1 error) {
	fake.agreeToTOSMutex.Lock()
	defer fake.agreeToTOSMutex.Unlock()
	fake.AgreeToTOSStub = nil
	fake.agreeToTOSReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) AgreeToTOSReturnsOnCall(i int, result1 error) {
	fake.agreeToTOSMutex.Lock()
	defer fake.agreeToTOSMutex.Unlock()
	fake.AgreeToTOSStub = nil
	if fake.agreeToTOSReturnsOnCall == nil {
		fake.agreeToTOSReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.agreeToTOSReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) DeleteRegistration() error {
	fake.deleteRegistrationMutex.Lock()
	ret, specificReturn := fake.deleteRegistrationReturnsOnCall[len(fake.deleteRegistrationArgsForCall)]
	fake.deleteRegistrationArgsForCall = append(fake.deleteRegistrationArgsForCall, struct {
	}{})
	fake.recordInvocation("DeleteRegistration", []interface{}{})
	fake.deleteRegistrationMutex.Unlock()
	if fake.DeleteRegistrationStub != nil {
		return fake.DeleteRegistrationStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteRegistrationReturns
	return fakeReturns.result1
}

func (fake *FakeAcmeClient) DeleteRegistrationCallCount() int {
	fake.deleteRegistrationMutex.RLock()
	defer fake.deleteRegistrationMutex.RUnlock()
	return len(fake.deleteRegistrationArgsForCall)
}

func (fake *FakeAcmeClient) DeleteRegistrationCalls(stub func() error) {
	fake.deleteRegistrationMutex.Lock()
	defer fake.deleteRegistrationMutex.Unlock()
	fake.DeleteRegistrationStub = stub
}

func (fake *FakeAcmeClient) DeleteRegistrationReturns(result1 error) {
	fake.deleteRegistrationMutex.Lock()
	defer fake.deleteRegistrationMutex.Unlock()
	fake.DeleteRegistrationStub = nil
	fake.deleteRegistrationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) DeleteRegistrationReturnsOnCall(i int, result1 error) {
	fake.deleteRegistrationMutex.Lock()
	defer fake.deleteRegistrationMutex.Unlock()
	fake.DeleteRegistrationStub = nil
	if fake.deleteRegistrationReturnsOnCall == nil {
		fake.deleteRegistrationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRegistrationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) ExcludeChallenges(arg1 []acme.Challenge) {
	var arg1Copy []acme.Challenge
	if arg1 != nil {
		arg1Copy = make([]acme.Challenge, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.excludeChallengesMutex.Lock()
	fake.excludeChallengesArgsForCall = append(fake.excludeChallengesArgsForCall, struct {
		arg1 []acme.Challenge
	}{arg1Copy})
	fake.recordInvocation("ExcludeChallenges", []interface{}{arg1Copy})
	fake.excludeChallengesMutex.Unlock()
	if fake.ExcludeChallengesStub != nil {
		fake.ExcludeChallengesStub(arg1)
	}
}

func (fake *FakeAcmeClient) ExcludeChallengesCallCount() int {
	fake.excludeChallengesMutex.RLock()
	defer fake.excludeChallengesMutex.RUnlock()
	return len(fake.excludeChallengesArgsForCall)
}

func (fake *FakeAcmeClient) ExcludeChallengesCalls(stub func([]acme.Challenge)) {
	fake.excludeChallengesMutex.Lock()
	defer fake.excludeChallengesMutex.Unlock()
	fake.ExcludeChallengesStub = stub
}

func (fake *FakeAcmeClient) ExcludeChallengesArgsForCall(i int) []acme.Challenge {
	fake.excludeChallengesMutex.RLock()
	defer fake.excludeChallengesMutex.RUnlock()
	argsForCall := fake.excludeChallengesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAcmeClient) GetChallenges(arg1 []string) ([]acme.AuthorizationResource, map[string]error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getChallengesMutex.Lock()
	ret, specificReturn := fake.getChallengesReturnsOnCall[len(fake.getChallengesArgsForCall)]
	fake.getChallengesArgsForCall = append(fake.getChallengesArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("GetChallenges", []interface{}{arg1Copy})
	fake.getChallengesMutex.Unlock()
	if fake.GetChallengesStub != nil {
		return fake.GetChallengesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getChallengesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAcmeClient) GetChallengesCallCount() int {
	fake.getChallengesMutex.RLock()
	defer fake.getChallengesMutex.RUnlock()
	return len(fake.getChallengesArgsForCall)
}

func (fake *FakeAcmeClient) GetChallengesCalls(stub func([]string) ([]acme.AuthorizationResource, map[string]error)) {
	fake.getChallengesMutex.Lock()
	defer fake.getChallengesMutex.Unlock()
	fake.GetChallengesStub = stub
}

func (fake *FakeAcmeClient) GetChallengesArgsForCall(i int) []string {
	fake.getChallengesMutex.RLock()
	defer fake.getChallengesMutex.RUnlock()
	argsForCall := fake.getChallengesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAcmeClient) GetChallengesReturns(result1 []acme.AuthorizationResource, result2 map[string]error) {
	fake.getChallengesMutex.Lock()
	defer fake.getChallengesMutex.Unlock()
	fake.GetChallengesStub = nil
	fake.getChallengesReturns = struct {
		result1 []acme.AuthorizationResource
		result2 map[string]error
	}{result1, result2}
}

func (fake *FakeAcmeClient) GetChallengesReturnsOnCall(i int, result1 []acme.AuthorizationResource, result2 map[string]error) {
	fake.getChallengesMutex.Lock()
	defer fake.getChallengesMutex.Unlock()
	fake.GetChallengesStub = nil
	if fake.getChallengesReturnsOnCall == nil {
		fake.getChallengesReturnsOnCall = make(map[int]struct {
			result1 []acme.AuthorizationResource
			result2 map[string]error
		})
	}
	fake.getChallengesReturnsOnCall[i] = struct {
		result1 []acme.AuthorizationResource
		result2 map[string]error
	}{result1, result2}
}

func (fake *FakeAcmeClient) ObtainCertificate(arg1 []string, arg2 bool, arg3 crypto.PrivateKey, arg4 bool) (acme.CertificateResource, map[string]error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.obtainCertificateMutex.Lock()
	ret, specificReturn := fake.obtainCertificateReturnsOnCall[len(fake.obtainCertificateArgsForCall)]
	fake.obtainCertificateArgsForCall = append(fake.obtainCertificateArgsForCall, struct {
		arg1 []string
		arg2 bool
		arg3 crypto.PrivateKey
		arg4 bool
	}{arg1Copy, arg2, arg3, arg4})
	fake.recordInvocation("ObtainCertificate", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.obtainCertificateMutex.Unlock()
	if fake.ObtainCertificateStub != nil {
		return fake.ObtainCertificateStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.obtainCertificateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAcmeClient) ObtainCertificateCallCount() int {
	fake.obtainCertificateMutex.RLock()
	defer fake.obtainCertificateMutex.RUnlock()
	return len(fake.obtainCertificateArgsForCall)
}

func (fake *FakeAcmeClient) ObtainCertificateCalls(stub func([]string, bool, crypto.PrivateKey, bool) (acme.CertificateResource, map[string]error)) {
	fake.obtainCertificateMutex.Lock()
	defer fake.obtainCertificateMutex.Unlock()
	fake.ObtainCertificateStub = stub
}

func (fake *FakeAcmeClient) ObtainCertificateArgsForCall(i int) ([]string, bool, crypto.PrivateKey, bool) {
	fake.obtainCertificateMutex.RLock()
	defer fake.obtainCertificateMutex.RUnlock()
	argsForCall := fake.obtainCertificateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAcmeClient) ObtainCertificateReturns(result1 acme.CertificateResource, result2 map[string]error) {
	fake.obtainCertificateMutex.Lock()
	defer fake.obtainCertificateMutex.Unlock()
	fake.ObtainCertificateStub = nil
	fake.obtainCertificateReturns = struct {
		result1 acme.CertificateResource
		result2 map[string]error
	}{result1, result2}
}

func (fake *FakeAcmeClient) ObtainCertificateReturnsOnCall(i int, result1 acme.CertificateResource, result2 map[string]error) {
	fake.obtainCertificateMutex.Lock()
	defer fake.obtainCertificateMutex.Unlock()
	fake.ObtainCertificateStub = nil
	if fake.obtainCertificateReturnsOnCall == nil {
		fake.obtainCertificateReturnsOnCall = make(map[int]struct {
			result1 acme.CertificateResource
			result2 map[string]error
		})
	}
	fake.obtainCertificateReturnsOnCall[i] = struct {
		result1 acme.CertificateResource
		result2 map[string]error
	}{result1, result2}
}

func (fake *FakeAcmeClient) ObtainCertificateForCSR(arg1 x509.CertificateRequest, arg2 bool) (acme.CertificateResource, map[string]error) {
	fake.obtainCertificateForCSRMutex.Lock()
	ret, specificReturn := fake.obtainCertificateForCSRReturnsOnCall[len(fake.obtainCertificateForCSRArgsForCall)]
	fake.obtainCertificateForCSRArgsForCall = append(fake.obtainCertificateForCSRArgsForCall, struct {
		arg1 x509.CertificateRequest
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("ObtainCertificateForCSR", []interface{}{arg1, arg2})
	fake.obtainCertificateForCSRMutex.Unlock()
	if fake.ObtainCertificateForCSRStub != nil {
		return fake.ObtainCertificateForCSRStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.obtainCertificateForCSRReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAcmeClient) ObtainCertificateForCSRCallCount() int {
	fake.obtainCertificateForCSRMutex.RLock()
	defer fake.obtainCertificateForCSRMutex.RUnlock()
	return len(fake.obtainCertificateForCSRArgsForCall)
}

func (fake *FakeAcmeClient) ObtainCertificateForCSRCalls(stub func(x509.CertificateRequest, bool) (acme.CertificateResource, map[string]error)) {
	fake.obtainCertificateForCSRMutex.Lock()
	defer fake.obtainCertificateForCSRMutex.Unlock()
	fake.ObtainCertificateForCSRStub = stub
}

func (fake *FakeAcmeClient) ObtainCertificateForCSRArgsForCall(i int) (x509.CertificateRequest, bool) {
	fake.obtainCertificateForCSRMutex.RLock()
	defer fake.obtainCertificateForCSRMutex.RUnlock()
	argsForCall := fake.obtainCertificateForCSRArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAcmeClient) ObtainCertificateForCSRReturns(result1 acme.CertificateResource, result2 map[string]error) {
	fake.obtainCertificateForCSRMutex.Lock()
	defer fake.obtainCertificateForCSRMutex.Unlock()
	fake.ObtainCertificateForCSRStub = nil
	fake.obtainCertificateForCSRReturns = struct {
		result1 acme.CertificateResource
		result2 map[string]error
	}{result1, result2}
}

func (fake *FakeAcmeClient) ObtainCertificateForCSRReturnsOnCall(i int, result1 acme.CertificateResource, result2 map[string]error) {
	fake.obtainCertificateForCSRMutex.Lock()
	defer fake.obtainCertificateForCSRMutex.Unlock()
	fake.ObtainCertificateForCSRStub = nil
	if fake.obtainCertificateForCSRReturnsOnCall == nil {
		fake.obtainCertificateForCSRReturnsOnCall = make(map[int]struct {
			result1 acme.CertificateResource
			result2 map[string]error
		})
	}
	fake.obtainCertificateForCSRReturnsOnCall[i] = struct {
		result1 acme.CertificateResource
		result2 map[string]error
	}{result1, result2}
}

func (fake *FakeAcmeClient) QueryRegistration() (*acme.RegistrationResource, error) {
	fake.queryRegistrationMutex.Lock()
	ret, specificReturn := fake.queryRegistrationReturnsOnCall[len(fake.queryRegistrationArgsForCall)]
	fake.queryRegistrationArgsForCall = append(fake.queryRegistrationArgsForCall, struct {
	}{})
	fake.recordInvocation("QueryRegistration", []interface{}{})
	fake.queryRegistrationMutex.Unlock()
	if fake.QueryRegistrationStub != nil {
		return fake.QueryRegistrationStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.queryRegistrationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAcmeClient) QueryRegistrationCallCount() int {
	fake.queryRegistrationMutex.RLock()
	defer fake.queryRegistrationMutex.RUnlock()
	return len(fake.queryRegistrationArgsForCall)
}

func (fake *FakeAcmeClient) QueryRegistrationCalls(stub func() (*acme.RegistrationResource, error)) {
	fake.queryRegistrationMutex.Lock()
	defer fake.queryRegistrationMutex.Unlock()
	fake.QueryRegistrationStub = stub
}

func (fake *FakeAcmeClient) QueryRegistrationReturns(result1 *acme.RegistrationResource, result2 error) {
	fake.queryRegistrationMutex.Lock()
	defer fake.queryRegistrationMutex.Unlock()
	fake.QueryRegistrationStub = nil
	fake.queryRegistrationReturns = struct {
		result1 *acme.RegistrationResource
		result2 error
	}{result1, result2}
}

func (fake *FakeAcmeClient) QueryRegistrationReturnsOnCall(i int, result1 *acme.RegistrationResource, result2 error) {
	fake.queryRegistrationMutex.Lock()
	defer fake.queryRegistrationMutex.Unlock()
	fake.QueryRegistrationStub = nil
	if fake.queryRegistrationReturnsOnCall == nil {
		fake.queryRegistrationReturnsOnCall = make(map[int]struct {
			result1 *acme.RegistrationResource
			result2 error
		})
	}
	fake.queryRegistrationReturnsOnCall[i] = struct {
		result1 *acme.RegistrationResource
		result2 error
	}{result1, result2}
}

func (fake *FakeAcmeClient) Register() (*acme.RegistrationResource, error) {
	fake.registerMutex.Lock()
	ret, specificReturn := fake.registerReturnsOnCall[len(fake.registerArgsForCall)]
	fake.registerArgsForCall = append(fake.registerArgsForCall, struct {
	}{})
	fake.recordInvocation("Register", []interface{}{})
	fake.registerMutex.Unlock()
	if fake.RegisterStub != nil {
		return fake.RegisterStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.registerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAcmeClient) RegisterCallCount() int {
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	return len(fake.registerArgsForCall)
}

func (fake *FakeAcmeClient) RegisterCalls(stub func() (*acme.RegistrationResource, error)) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = stub
}

func (fake *FakeAcmeClient) RegisterReturns(result1 *acme.RegistrationResource, result2 error) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = nil
	fake.registerReturns = struct {
		result1 *acme.RegistrationResource
		result2 error
	}{result1, result2}
}

func (fake *FakeAcmeClient) RegisterReturnsOnCall(i int, result1 *acme.RegistrationResource, result2 error) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = nil
	if fake.registerReturnsOnCall == nil {
		fake.registerReturnsOnCall = make(map[int]struct {
			result1 *acme.RegistrationResource
			result2 error
		})
	}
	fake.registerReturnsOnCall[i] = struct {
		result1 *acme.RegistrationResource
		result2 error
	}{result1, result2}
}

func (fake *FakeAcmeClient) RenewCertificate(arg1 acme.CertificateResource, arg2 bool, arg3 bool) (acme.CertificateResource, error) {
	fake.renewCertificateMutex.Lock()
	ret, specificReturn := fake.renewCertificateReturnsOnCall[len(fake.renewCertificateArgsForCall)]
	fake.renewCertificateArgsForCall = append(fake.renewCertificateArgsForCall, struct {
		arg1 acme.CertificateResource
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("RenewCertificate", []interface{}{arg1, arg2, arg3})
	fake.renewCertificateMutex.Unlock()
	if fake.RenewCertificateStub != nil {
		return fake.RenewCertificateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.renewCertificateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAcmeClient) RenewCertificateCallCount() int {
	fake.renewCertificateMutex.RLock()
	defer fake.renewCertificateMutex.RUnlock()
	return len(fake.renewCertificateArgsForCall)
}

func (fake *FakeAcmeClient) RenewCertificateCalls(stub func(acme.CertificateResource, bool, bool) (acme.CertificateResource, error)) {
	fake.renewCertificateMutex.Lock()
	defer fake.renewCertificateMutex.Unlock()
	fake.RenewCertificateStub = stub
}

func (fake *FakeAcmeClient) RenewCertificateArgsForCall(i int) (acme.CertificateResource, bool, bool) {
	fake.renewCertificateMutex.RLock()
	defer fake.renewCertificateMutex.RUnlock()
	argsForCall := fake.renewCertificateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAcmeClient) RenewCertificateReturns(result1 acme.CertificateResource, result2 error) {
	fake.renewCertificateMutex.Lock()
	defer fake.renewCertificateMutex.Unlock()
	fake.RenewCertificateStub = nil
	fake.renewCertificateReturns = struct {
		result1 acme.CertificateResource
		result2 error
	}{result1, result2}
}

func (fake *FakeAcmeClient) RenewCertificateReturnsOnCall(i int, result1 acme.CertificateResource, result2 error) {
	fake.renewCertificateMutex.Lock()
	defer fake.renewCertificateMutex.Unlock()
	fake.RenewCertificateStub = nil
	if fake.renewCertificateReturnsOnCall == nil {
		fake.renewCertificateReturnsOnCall = make(map[int]struct {
			result1 acme.CertificateResource
			result2 error
		})
	}
	fake.renewCertificateReturnsOnCall[i] = struct {
		result1 acme.CertificateResource
		result2 error
	}{result1, result2}
}

func (fake *FakeAcmeClient) RequestCertificate(arg1 []acme.AuthorizationResource, arg2 bool, arg3 crypto.PrivateKey, arg4 bool) (acme.CertificateResource, error) {
	var arg1Copy []acme.AuthorizationResource
	if arg1 != nil {
		arg1Copy = make([]acme.AuthorizationResource, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.requestCertificateMutex.Lock()
	ret, specificReturn := fake.requestCertificateReturnsOnCall[len(fake.requestCertificateArgsForCall)]
	fake.requestCertificateArgsForCall = append(fake.requestCertificateArgsForCall, struct {
		arg1 []acme.AuthorizationResource
		arg2 bool
		arg3 crypto.PrivateKey
		arg4 bool
	}{arg1Copy, arg2, arg3, arg4})
	fake.recordInvocation("RequestCertificate", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.requestCertificateMutex.Unlock()
	if fake.RequestCertificateStub != nil {
		return fake.RequestCertificateStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.requestCertificateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAcmeClient) RequestCertificateCallCount() int {
	fake.requestCertificateMutex.RLock()
	defer fake.requestCertificateMutex.RUnlock()
	return len(fake.requestCertificateArgsForCall)
}

func (fake *FakeAcmeClient) RequestCertificateCalls(stub func([]acme.AuthorizationResource, bool, crypto.PrivateKey, bool) (acme.CertificateResource, error)) {
	fake.requestCertificateMutex.Lock()
	defer fake.requestCertificateMutex.Unlock()
	fake.RequestCertificateStub = stub
}

func (fake *FakeAcmeClient) RequestCertificateArgsForCall(i int) ([]acme.AuthorizationResource, bool, crypto.PrivateKey, bool) {
	fake.requestCertificateMutex.RLock()
	defer fake.requestCertificateMutex.RUnlock()
	argsForCall := fake.requestCertificateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAcmeClient) RequestCertificateReturns(result1 acme.CertificateResource, result2 error) {
	fake.requestCertificateMutex.Lock()
	defer fake.requestCertificateMutex.Unlock()
	fake.RequestCertificateStub = nil
	fake.requestCertificateReturns = struct {
		result1 acme.CertificateResource
		result2 error
	}{result1, result2}
}

func (fake *FakeAcmeClient) RequestCertificateReturnsOnCall(i int, result1 acme.CertificateResource, result2 error) {
	fake.requestCertificateMutex.Lock()
	defer fake.requestCertificateMutex.Unlock()
	fake.RequestCertificateStub = nil
	if fake.requestCertificateReturnsOnCall == nil {
		fake.requestCertificateReturnsOnCall = make(map[int]struct {
			result1 acme.CertificateResource
			result2 error
		})
	}
	fake.requestCertificateReturnsOnCall[i] = struct {
		result1 acme.CertificateResource
		result2 error
	}{result1, result2}
}

func (fake *FakeAcmeClient) RevokeCertificate(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.revokeCertificateMutex.Lock()
	ret, specificReturn := fake.revokeCertificateReturnsOnCall[len(fake.revokeCertificateArgsForCall)]
	fake.revokeCertificateArgsForCall = append(fake.revokeCertificateArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("RevokeCertificate", []interface{}{arg1Copy})
	fake.revokeCertificateMutex.Unlock()
	if fake.RevokeCertificateStub != nil {
		return fake.RevokeCertificateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.revokeCertificateReturns
	return fakeReturns.result1
}

func (fake *FakeAcmeClient) RevokeCertificateCallCount() int {
	fake.revokeCertificateMutex.RLock()
	defer fake.revokeCertificateMutex.RUnlock()
	return len(fake.revokeCertificateArgsForCall)
}

func (fake *FakeAcmeClient) RevokeCertificateCalls(stub func([]byte) error) {
	fake.revokeCertificateMutex.Lock()
	defer fake.revokeCertificateMutex.Unlock()
	fake.RevokeCertificateStub = stub
}

func (fake *FakeAcmeClient) RevokeCertificateArgsForCall(i int) []byte {
	fake.revokeCertificateMutex.RLock()
	defer fake.revokeCertificateMutex.RUnlock()
	argsForCall := fake.revokeCertificateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAcmeClient) RevokeCertificateReturns(result1 error) {
	fake.revokeCertificateMutex.Lock()
	defer fake.revokeCertificateMutex.Unlock()
	fake.RevokeCertificateStub = nil
	fake.revokeCertificateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) RevokeCertificateReturnsOnCall(i int, result1 error) {
	fake.revokeCertificateMutex.Lock()
	defer fake.revokeCertificateMutex.Unlock()
	fake.RevokeCertificateStub = nil
	if fake.revokeCertificateReturnsOnCall == nil {
		fake.revokeCertificateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.revokeCertificateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) SetChallengeProvider(arg1 acme.Challenge, arg2 acme.ChallengeProvider) error {
	fake.setChallengeProviderMutex.Lock()
	ret, specificReturn := fake.setChallengeProviderReturnsOnCall[len(fake.setChallengeProviderArgsForCall)]
	fake.setChallengeProviderArgsForCall = append(fake.setChallengeProviderArgsForCall, struct {
		arg1 acme.Challenge
		arg2 acme.ChallengeProvider
	}{arg1, arg2})
	fake.recordInvocation("SetChallengeProvider", []interface{}{arg1, arg2})
	fake.setChallengeProviderMutex.Unlock()
	if fake.SetChallengeProviderStub != nil {
		return fake.SetChallengeProviderStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setChallengeProviderReturns
	return fakeReturns.result1
}

func (fake *FakeAcmeClient) SetChallengeProviderCallCount() int {
	fake.setChallengeProviderMutex.RLock()
	defer fake.setChallengeProviderMutex.RUnlock()
	return len(fake.setChallengeProviderArgsForCall)
}

func (fake *FakeAcmeClient) SetChallengeProviderCalls(stub func(acme.Challenge, acme.ChallengeProvider) error) {
	fake.setChallengeProviderMutex.Lock()
	defer fake.setChallengeProviderMutex.Unlock()
	fake.SetChallengeProviderStub = stub
}

func (fake *FakeAcmeClient) SetChallengeProviderArgsForCall(i int) (acme.Challenge, acme.ChallengeProvider) {
	fake.setChallengeProviderMutex.RLock()
	defer fake.setChallengeProviderMutex.RUnlock()
	argsForCall := fake.setChallengeProviderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAcmeClient) SetChallengeProviderReturns(result1 error) {
	fake.setChallengeProviderMutex.Lock()
	defer fake.setChallengeProviderMutex.Unlock()
	fake.SetChallengeProviderStub = nil
	fake.setChallengeProviderReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) SetChallengeProviderReturnsOnCall(i int, result1 error) {
	fake.setChallengeProviderMutex.Lock()
	defer fake.setChallengeProviderMutex.Unlock()
	fake.SetChallengeProviderStub = nil
	if fake.setChallengeProviderReturnsOnCall == nil {
		fake.setChallengeProviderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setChallengeProviderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) SetHTTPAddress(arg1 string) error {
	fake.setHTTPAddressMutex.Lock()
	ret, specificReturn := fake.setHTTPAddressReturnsOnCall[len(fake.setHTTPAddressArgsForCall)]
	fake.setHTTPAddressArgsForCall = append(fake.setHTTPAddressArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetHTTPAddress", []interface{}{arg1})
	fake.setHTTPAddressMutex.Unlock()
	if fake.SetHTTPAddressStub != nil {
		return fake.SetHTTPAddressStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setHTTPAddressReturns
	return fakeReturns.result1
}

func (fake *FakeAcmeClient) SetHTTPAddressCallCount() int {
	fake.setHTTPAddressMutex.RLock()
	defer fake.setHTTPAddressMutex.RUnlock()
	return len(fake.setHTTPAddressArgsForCall)
}

func (fake *FakeAcmeClient) SetHTTPAddressCalls(stub func(string) error) {
	fake.setHTTPAddressMutex.Lock()
	defer fake.setHTTPAddressMutex.Unlock()
	fake.SetHTTPAddressStub = stub
}

func (fake *FakeAcmeClient) SetHTTPAddressArgsForCall(i int) string {
	fake.setHTTPAddressMutex.RLock()
	defer fake.setHTTPAddressMutex.RUnlock()
	argsForCall := fake.setHTTPAddressArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAcmeClient) SetHTTPAddressReturns(result1 error) {
	fake.setHTTPAddressMutex.Lock()
	defer fake.setHTTPAddressMutex.Unlock()
	fake.SetHTTPAddressStub = nil
	fake.setHTTPAddressReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) SetHTTPAddressReturnsOnCall(i int, result1 error) {
	fake.setHTTPAddressMutex.Lock()
	defer fake.setHTTPAddressMutex.Unlock()
	fake.SetHTTPAddressStub = nil
	if fake.setHTTPAddressReturnsOnCall == nil {
		fake.setHTTPAddressReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setHTTPAddressReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) SetTLSAddress(arg1 string) error {
	fake.setTLSAddressMutex.Lock()
	ret, specificReturn := fake.setTLSAddressReturnsOnCall[len(fake.setTLSAddressArgsForCall)]
	fake.setTLSAddressArgsForCall = append(fake.setTLSAddressArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetTLSAddress", []interface{}{arg1})
	fake.setTLSAddressMutex.Unlock()
	if fake.SetTLSAddressStub != nil {
		return fake.SetTLSAddressStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setTLSAddressReturns
	return fakeReturns.result1
}

func (fake *FakeAcmeClient) SetTLSAddressCallCount() int {
	fake.setTLSAddressMutex.RLock()
	defer fake.setTLSAddressMutex.RUnlock()
	return len(fake.setTLSAddressArgsForCall)
}

func (fake *FakeAcmeClient) SetTLSAddressCalls(stub func(string) error) {
	fake.setTLSAddressMutex.Lock()
	defer fake.setTLSAddressMutex.Unlock()
	fake.SetTLSAddressStub = stub
}

func (fake *FakeAcmeClient) SetTLSAddressArgsForCall(i int) string {
	fake.setTLSAddressMutex.RLock()
	defer fake.setTLSAddressMutex.RUnlock()
	argsForCall := fake.setTLSAddressArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAcmeClient) SetTLSAddressReturns(result1 error) {
	fake.setTLSAddressMutex.Lock()
	defer fake.setTLSAddressMutex.Unlock()
	fake.SetTLSAddressStub = nil
	fake.setTLSAddressReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) SetTLSAddressReturnsOnCall(i int, result1 error) {
	fake.setTLSAddressMutex.Lock()
	defer fake.setTLSAddressMutex.Unlock()
	fake.SetTLSAddressStub = nil
	if fake.setTLSAddressReturnsOnCall == nil {
		fake.setTLSAddressReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setTLSAddressReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAcmeClient) SolveChallenges(arg1 []acme.AuthorizationResource) map[string]error {
	var arg1Copy []acme.AuthorizationResource
	if arg1 != nil {
		arg1Copy = make([]acme.AuthorizationResource, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.solveChallengesMutex.Lock()
	ret, specificReturn := fake.solveChallengesReturnsOnCall[len(fake.solveChallengesArgsForCall)]
	fake.solveChallengesArgsForCall = append(fake.solveChallengesArgsForCall, struct {
		arg1 []acme.AuthorizationResource
	}{arg1Copy})
	fake.recordInvocation("SolveChallenges", []interface{}{arg1Copy})
	fake.solveChallengesMutex.Unlock()
	if fake.SolveChallengesStub != nil {
		return fake.SolveChallengesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.solveChallengesReturns
	return fakeReturns.result1
}

func (fake *FakeAcmeClient) SolveChallengesCallCount() int {
	fake.solveChallengesMutex.RLock()
	defer fake.solveChallengesMutex.RUnlock()
	return len(fake.solveChallengesArgsForCall)
}

func (fake *FakeAcmeClient) SolveChallengesCalls(stub func([]acme.AuthorizationResource) map[string]error) {
	fake.solveChallengesMutex.Lock()
	defer fake.solveChallengesMutex.Unlock()
	fake.SolveChallengesStub = stub
}

func (fake *FakeAcmeClient) SolveChallengesArgsForCall(i int) []acme.AuthorizationResource {
	fake.solveChallengesMutex.RLock()
	defer fake.solveChallengesMutex.RUnlock()
	argsForCall := fake.solveChallengesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAcmeClient) SolveChallengesReturns(result1 map[string]error) {
	fake.solveChallengesMutex.Lock()
	defer fake.solveChallengesMutex.Unlock()
	fake.SolveChallengesStub = nil
	fake.solveChallengesReturns = struct {
		result1 map[string]error
	}{result1}
}

func (fake *FakeAcmeClient) SolveChallengesReturnsOnCall(i int, result1 map[string]error) {
	fake.solveChallengesMutex.Lock()
	defer fake.solveChallengesMutex.Unlock()
	fake.SolveChallengesStub = nil
	if fake.solveChallengesReturnsOnCall == nil {
		fake.solveChallengesReturnsOnCall = make(map[int]struct {
			result1 map[string]error
		})
	}
	fake.solveChallengesReturnsOnCall[i] = struct {
		result1 map[string]error
	}{result1}
}

func (fake *FakeAcmeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.agreeToTOSMutex.RLock()
	defer fake.agreeToTOSMutex.RUnlock()
	fake.deleteRegistrationMutex.RLock()
	defer fake.deleteRegistrationMutex.RUnlock()
	fake.excludeChallengesMutex.RLock()
	defer fake.excludeChallengesMutex.RUnlock()
	fake.getChallengesMutex.RLock()
	defer fake.getChallengesMutex.RUnlock()
	fake.obtainCertificateMutex.RLock()
	defer fake.obtainCertificateMutex.RUnlock()
	fake.obtainCertificateForCSRMutex.RLock()
	defer fake.obtainCertificateForCSRMutex.RUnlock()
	fake.queryRegistrationMutex.RLock()
	defer fake.queryRegistrationMutex.RUnlock()
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	fake.renewCertificateMutex.RLock()
	defer fake.renewCertificateMutex.RUnlock()
	fake.requestCertificateMutex.RLock()
	defer fake.requestCertificateMutex.RUnlock()
	fake.revokeCertificateMutex.RLock()
	defer fake.revokeCertificateMutex.RUnlock()
	fake.setChallengeProviderMutex.RLock()
	defer fake.setChallengeProviderMutex.RUnlock()
	fake.setHTTPAddressMutex.RLock()
	defer fake.setHTTPAddressMutex.RUnlock()
	fake.setTLSAddressMutex.RLock()
	defer fake.setTLSAddressMutex.RUnlock()
	fake.solveChallengesMutex.RLock()
	defer fake.solveChallengesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAcmeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ acme.ClientInterface = new(FakeAcmeClient)
